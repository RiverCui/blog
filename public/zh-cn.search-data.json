{"/capture-https-request-with-mobile-device/":{"data":{"":"","#":"最近在为公司重构项目，因为原本是原生安卓和ios应用，所以为了快速了解业务逻辑和编写新代码，我决定一边用手机操作业务进行抓包，一边对照已有文档、代码进行重构。这篇文章介绍了我是如何用一台电脑和手机来实现抓包移动设备网络请求的。\n首先介绍一下使用的工具 —— Charles，这是一款网络抓包工具，它允许开发者查看、监控发送和接收的HTTP/HTTPS通信数据，主要面向开发者对 Web应用、移动 App 等进行网络调试和分析。你可以点击进入 Charles 官网下载，支持 Windows、macOS 和 Linux。\n基本使用 安装好 Charles 后，可以按照我下面给出的步骤进行使用：\n1. 让你的手机和电脑处在同一局域网 2. 电脑运行 Charles（默认端口号 8888） 3. 打开手机的 WLAN 设置 修改以下三项，可参考下方小米手机截图：\n代理：改为手动\n主机名：填写你的电脑 IP\n端口号： 8888（8888 为 Charles 默认端口号，如有需要可以在 Charles 中的 Proxy Settings 修改）\n4. 在手机中打开需要抓取的 App 现在你可以看到 Charles 已经开始正常运行，开始抓取 HTTP 请求了。\n虽然 HTTP 请求抓取正常，但你也许会和我一样，有需要抓取 HTTPS 请求的使用场景，但此时 Charles 抓包会出现乱码，这是由于 HTTPS 更高的安全性，我们要提供证书才可以正常获取数据。\n配置以抓包 HTTPS Request 在移动设备上安装证书：\n1. 配置 Charles 的 SSL Proxy -\u003e SSL Proxying Settings\n添加 *:443。\n2. 从 Charles 下载证书 打开 Charles，Help -\u003e SSL Proxying，因为我们使用的是手机，所以这里就选择 Mobile Device。\nCharles 会弹出提示，我们根据提示，用手机访问 chls.pro/ssl 下载证书。\n3. 手机安装证书 还是以小米手机为例，系统是 MUI 13.0.7，安装证书步骤如下：\n安全 -\u003e 更多安全设置 -\u003e 加密与凭据 -\u003e 安装证书 -\u003e CA 证书，然后选择刚才下载好的 Charles 证书安装\n现在再打开 Charles，可以看到抓到的 HTTPS 请求信息了。"},"title":"使用 Charles 抓取移动设备 HTTPS 请求"},"/css-masonry/":{"data":{"":"","#":"围绕 Masonry 展开的辩论 前段时间，WebKit 团队发表了一篇名为 Help us invent CSS Grid Level 3, aka “Masonry” layout 的文章，讨论了关于 Masonry layout 的提案。\nMasonry 在英文中的意思是建筑物的砖石部分（如下图）。\nmasonry 布局是一种类似砖墙或石墙的模式的布局，也就是我们常说的瀑布流布局，这种布局样式很常见，比如 Pinterest 、小红书等都采用了这种样式。\nMasonry 是最开始也是由 WebKit 团队提出的，你可以在 MDN 上查看到它的使用方法（现在只有 Safari 和 Firefox 浏览器支持）。而在 WebKit 发表的这篇文章中，他们解释了为什么他们认为 Masonry 应该成为 CSS Grid 的一部分，并且解释了如果 CSS Working Group 使用替换方案 display: masonry 的可行性，并且向开发者、设计师寻求建议。\nChrome 团队也在前几日站出来，发表了一篇名为 An alternative proposal for CSS masonry 的文章，关于 CSS Masonry，他们明确的提出了 “implementing it as a part of the CSS Grid specification [..] would be a mistake\"（将其作为 CSS Grid 规范的一部分是个错误）的观点。\nMasonry 怎么用 虽然瀑布流很常见，但是作为一名前端工程师，我还从未写过这种样式，趁热打铁，就用这个新布局来写一个瀑布流页面。\n首先我们建一个 html 文件，添加一些图片做瀑布流使用。\n\u003cdiv class=\"gallery-container\"\u003e \u003cfigure\u003e \u003cimg src=\"https://picsum.photos/seed/1715619706392/500/500\"\u003e \u003c/figure\u003e \u003cfigure\u003e \u003cimg src=\"https://picsum.photos/seed/1715619668573/500/1000\"\u003e \u003c/figure\u003e \u003cfigure\u003e \u003cimg src=\"https://picsum.photos/seed/1715619707240/500/500\"\u003e \u003c/figure\u003e \u003cfigure\u003e \u003cimg src=\"https://picsum.photos/seed/1715619669966/500/1000\"\u003e \u003c/figure\u003e \u003cfigure\u003e \u003cimg src=\"https://picsum.photos/seed/1715619687217/500/800\"\u003e \u003c/figure\u003e \u003cfigure\u003e \u003cimg src=\"https://picsum.photos/seed/1715619713060/500/500\"\u003e \u003c/figure\u003e \u003c/div\u003e 然后写入 CSS，通过 grid-template-rows: masonry 来实现瀑布流布局。\nimg { width: 500px; object-fit: contain; border-radius: 15px; } .gallery-container { display: grid; grid-template-columns: repeat(3, 1fr); grid-gap: 1rem; grid-template-rows: masonry; } 我们可以看到，虽然 grid 布局生效了，但 grid-template-rows: masonry 并未生效，图与图之间存在大片的空白。\n这是因为 Masonry 目前只是个实验性功能，大部分浏览器还不支持，你可以下载 Safari Technology Preview 或者 Firefox Nightly 来体验这个新特性。\n我使用的是 safari tp，如下图所示，一个简单的瀑布流就实现了。\n得益于 masonry，整个实现过程非常简单。附上完整代码：waterfall-demo\n我的观点 首次使用这个新功能的时候，有些地方是很迷惑的。\n首先，作为一个 non-native English speaker，masonry 这个词对我来说非常陌生，并不像 CSS 中常见的 border、center、none 让人一目了然，是有语言门槛的。\n其次，对于 grid-template-columns/grid-template-rows 搭配 masonry 使用，与我的思维习惯相悖，简单来说就是，要想实现纵向的瀑布流，需要使用 grid-template-rows: masonry，而我潜意识认为是 grid-template-columns。这里有点像一个习惯使用 windows 的人，第一次用 macos 浏览网页对于上下滚动的无所适从。\n总结一下，我对 Masonry 的建议有两点：\n将 masonry 这个单词换成更容易理解的 waterfall 和 chrome 团队的观点一样，Masonry 不应该是 Grid 的一部分，应该单独的使用 —— display: masonry。 "},"title":"CSS Masonry"},"/docker-proxy-configuration/":{"data":{"":"Docker Desktop 登录失败有很多原因，如果使用网页打开 Docker Hub 登录没问题，但是 Docker Desktop 登录超时，大概率是因为代理问题，可以参考下面的方法进行配置。","登录问题#登录问题":"首先你要有一个代理（自行 Google），获取到代理的端口号。例如我使用的是 Clash，在设置中可以看到端口号为 7897。\n打开 Docker Desktop 设置，Resource -\u003e Proxies。\n打开 Manual Proxy configuration 状态，添加 Web Server(HTTP) 和 Web Server(HTTPS)，端口号为代理端口号。\n重启 Docker Desktop 就可以正常登录了。","镜像加速#镜像加速":"国内从 Docker Hub 拉去镜像有时会遇到困难，可以参考国内的 Docker Hub 镜像加速器配置镜像加速。"},"title":"Docker 代理配置（解决登录失败问题）"},"/event-loop-in-javascript/":{"data":{"":"","event-loop-执行流程#Event Loop 执行流程":"Event Loop 的执行流程可以分为以下几个步骤：\n执行同步代码\n执行当前宏任务中的所有同步代码\n清空微任务队列\n当同步代码执行完毕后，立即检查微任务队列\n执行所有微任务，直到清空微任务队列\n如果在清空微任务队列时，产生了新的微任务，也会立即执行\nUI 渲染\n微任务队列清空后，检查是否需要 UI 渲染，如果需要就进行 UI 渲染\n执行下一个宏任务\n从宏任务队列中取出一个任务执行，重复2-4的步骤\n🔥 微任务的优先级比宏任务高，在 DOM 渲染前执行，且会一次性执行完毕。宏任务在 DOM 渲染后执行，一次只执行一个宏任务，然后进入下一次事件循环。 例子 理解 Event Loop 最好的方法就是实践，让我们来举个例子，下面这段代码会如何执行：\nconsole.log('start') setTimeout(() =\u003e { console.log('setTimeout') }, 0) Promise.resolve().then(() =\u003e { console.log('promise1') }).then(() =\u003e { console.log('promise2') }) console.log('end') 运行结果：\nstart end promise1 promise2 setTimeout 执行流程分析：\nprint start 执行 setTimeout，将回调函数注册到宏任务队列 执行 Promise，将回调函数注册到微任务队列 print end Call Stack 清空 执行所有微任务，print promise1、promise2，微任务队列清空 取宏任务队列中的第一个执行，print setTimeout ","event-loop-是什么#Event Loop 是什么":"Event Loop 是 JavaScript 实现异步的核心机制，解决 JavaScript 单线程带来的运行阻塞的问题。\nJavaScript 之所以是单线程，是因为最初被用来设计处理网页交互时，需要操作 DOM，如果是多线程，一个线程正在修改 DOM，另一个线程也在修改同一个 DOM，会导致冲突和复杂的并发问题。\n宏任务和微任务 首先看下 HTML 规范，从中可得知关于 Event Loop 的几个要点：\ntask queue 宏任务队列 每个 event loop 中有一个或多个 task queue，task queue 是一个集合而不是队列。\n这里说 task queue 是一个集合(set)，而不是队列(list)，是因为 event loop 会从 task queue 中抓取第一个可运行的任务，而不是按照队列顺序一个个地出队。\nmicrotask queue 微任务队列 每个 event loop 有一个 microtask queue，用于存放微任务，microtask 不是 task queue\n在浏览器中，常见的宏任务、微任务如下：\n宏任务 setTimeout setInterval setImmediate I/O 事件 MessageChannel 微任务 Promise.then/catch/finally process.nextTick (Node.js 环境，优先级高于 Promise) MutationObserver (监视 DOM 变化) queueMicroTask (直接创建微任务的方法) 一图了解 Event Loop 了解完宏任务、微任务，我们可以看下这张图，在 JavaScript 实际运行的过程中，代码被一行行执行，任务会被加入到执行栈中(call stack)，执行完毕后从栈中弹出。JavaScript 提供的 WebAPIs (例如 setTimeout、DOM、fetch 等)方法会将它们的回调添加到 task queue 中，等待执行。queueMicrotask、Promise、MutationObserver 等方法会创建微任务，添加到 microtask queue 中等待执行。\nEvent Loop 事件循环在其中负责这几件事：\n监控调用栈(call stack) 管理任务队列(task queue/microtask queue) Event Loop 事件循环机制保证 JavaScript 能够在单线程环境中有效地进行异步编程，从而提高应用程序的响应性和性能，让我们来看看它的机制具体是怎样的。","see-also#See Also":"HTML standard - event loops"},"title":"JavaScript 中的 Event Loop"},"/how-to-manage-files-on-cloud-storage-with-rclone/":{"data":{"":"在现代数据管理中，云存储已经成为不可或缺的一部分。无论是个人用户还是企业用户，云存储都提供了便捷的存储和访问方式。本文将介绍如何使用 Rclone 这个强大的命令行工具来管理阿里云 OSS(对象存储服务) 文件。","什么是-rclone#什么是 Rclone？":"Rclone 是一个开源命令行程序，支持多种云存储服务，包括 Google Drive、Amazon S3(阿里云OSS、腾讯COS、华为OBS等)、Dropbox。他可以用于同步文件、备份数据、迁移存储，以及其他文件管理任务。Rclone 提供了丰富的功能，如加密、压缩、多线程下载等，非常适合高效管理云存储文件。\n它支持以下功能：\n按需复制，每次仅仅复制更改的文件 断电续传 压缩传输 ","安装-rclone#安装 Rclone":"首先，我们需要安装 Rclone。可以从 Rclone 官网 下载适合你操作系统的安装包，并按照响应的安装步骤进行安装。\n对于 macOS 用户，可以通过 brew 进行安装：\nbrew install rclone 如果你是 Windows 用户，可以下载 .exe 文件并运行安装程序。","常用操作示例#常用操作示例":"列出存储桶(bucket)中的文件 rclone ls alioss:your-bucket-name 上传文件到bucket rclone copy /path/to/local/file alioss:your-bucket-name 下载文件到本地 rclone copy alioss:your-bucket-name /path/to/local/dir 同步本地目录和存储桶 rclone sync /path/to/local/dir alioss:your-bucket-name ","总结#总结":"Rclone 是一个功能强大的工具，能够帮助你高效地管理阿里云 OSS 或是其他云服务的文件，通过简单的配置和命令行操作，你可以轻松实现文件的上传\n、下载和同步等任务。希望本文能够帮助你快速上手 Rclone，并充分利用其强大的功能来管理你的云存储文件。","配置-rclone-连接阿里云-oss#配置 Rclone 连接阿里云 OSS":"安装完成后，我们需要配置 Rclone 以链接阿里云 OSS。打开终端(Terminal)，输入以下命令启动配置向导：\nrclone config 接下来，你会看到一个交互式的配置界面：\nNo remotes found - make a new one n) New remote s) Set configuration password q) Quit config n/s/q\u003e 输入 n 并按回车，开始创建一个新的 remote。然后按照提示输入以下信息：\nremote 名称：例如alioss 存储类型：输入 4，即 Amazon S3 Compliant Storage Providers 服务提供商：输入 2，即 Alibaba Cloud Object Storage System (OSS) formerly Aliyun Access Key ID 和 ACCESS Key Secret：从阿里云 OSS 控制台获取 Endpoint：选择你的 OSS 终端节点，例如 oss-cn-shenzhen.aliyuncs.com 其他选项：根据需要配置，通常可以使用默认值 配置完成后，保存并退出。"},"title":"如何使用 Rclone 高效管理云存储文件"},"/https-for-local-development/":{"data":{"":"我最近在开发一个能够提供扫码功能的网页，但是扫码功能需要调用相机权限，浏览器出于安全考虑只在 HTTPS 环境下允许。所以想要在本地调试这些功能，需要为本地开发服务器配置 HTTPS。解决这个问题的本质就是生成本地证书和自签名，网上能找到很多方法，在这里我会介绍两种，看到这篇博客的朋友可以跟着下面的步骤实践，足够你在简单基础的开发中去使用。","mkcert#mkcert":"mkcert 是一个简化了的本地 CA 工具，用来生成有效的本地 HTTPS 证书。mkcert 的使用和证书配置步骤如下：\n1.安装 如果你也是 macOS 系统且安装了 homebrew，可以按照下面这个方式进行安装：\nbrew instal mkcert brew install nss # 如果电脑中有 Firefox，还需要这一步骤，否则会报错 如果你是 Windows，可以点击此处查看安装步骤。\n2.安装本地 CA mkcert -install 3.为 localhost 创建证书 mkcert localhost 127.0.0.1 ::1 创建成功后，Terminal 会显示证书的存放位置和过期时间，如下：\nThe certificate is at \"./localhost+2.pem\" and the key at \"./localhost+2-key.pem\" ✅ It will expire on 25 March 2026 🗓 4.将证书存放在项目中 在项目目录下新建一个文件夹，方便管理证书。\n例如我在我的项目目录下新建了一个 cert 的文件夹，并将刚才生成的 localhost+2.pem 和 localhost+2-key.pem 移动到该目录下。\n5.配置 vite 以使用 HTTPS 我的项目技术栈是 vue3 + vite，所以这里配置的是 vite.config.js 文件，如果你使用其他构建工具(比如vue-cli + webpack)，配置方法也都大同小异，只需查阅官方文档做出相应调整即可。 注意：修改配置后记得重新运行服务。\n// vite.config.js import fs from 'fs'; import path from 'path'; export default defineConfig({ // ... server: { // ... https: { key: fs.readFileSync(path.resolve(__dirname, 'cert/localhost+2-key.pem')), cert: fs.readFileSync(path.resolve(__dirname, 'cert/localhost+2.pem')), }, }, }) ","vue--react-自带选项#Vue / React 自带选项":"不管是 React 还是 Vue，都自带了开启 HTTPS 的选项，这也使得我们在本地使用 HTTPS 协议更加简单。\n也以 vite 为例，官方文档中有提到，如果需要合法证书，可以使用它们提供的插件 @vitejs/plugin-basic-ssl，这个插件会自动创建和缓存一个自签名的证书。\n1.安装插件 @vitejs/plugin-basic-ssl： pnpm add @vitejs/plugin-basic/ssl -D 2.配置 vite 配置 vite 后运行即可，需要注意浏览器可能会有安全警告，这是因为我们生成的自签名证书不是受信任的证书颁发机构签发的，但不妨碍我们开发使用，只要不投入生产环境使用就没问题。\n// vite.config.js export default defineConfig({ // ... plugins: [ // ... basicSsl(), ], server: { // ... https: true, }, }) "},"title":"使用 mkcert/Vite 生成本地证书"},"/module-management/":{"data":{"":"","commonjs#\u003ccode\u003eCommonJS\u003c/code\u003e":"","es-modules#\u003ccode\u003eES Modules\u003c/code\u003e":"","esm-向下兼容#\u003ccode\u003eESM\u003c/code\u003e 向下兼容":"模块化及其优势 Node.js 与 浏览器的 JavaScript 最大不同就在于 Node.js 是模块化的。\n模块化 模块化是一种编程范式，将大型、复杂的程序系统分解成更小、更易管理和维护的部分。在模块化中，每个模块执行一项特定的功能，同时尽可能减少与其他模块的直接交互。这样的方法有很多优点：\n封装。每个模块将数据和功能封装在模块内部，并提供接口与外界交互。有助于隐藏内部实现细节，减少模块间的相互依赖。 重用性。模块化可以使开发者在项目多处重复使用代码块，也可以在多个项目或应用程序中使用，减少重复代码的编写，提高代码整体质量。 可维护性和可读性。模块化代码通常更易于理解和维护，每个模块负责清晰定义的功能，使得代码更加直观和易于管理。 独立性。模块之间的松耦合确保了修改一个模块不会或很少影响其他模块，有助于添加、更新和修复功能。 Node.js 的模块化选择 在 Node.js 诞生之初，JavaScript 还没有标准的模块机制，因此 Node.js 一开始采用了 CommonJS(下文简写为 CJS)。随后，JavaScript 标准的模块化机制 ES Modules(下文简写为 ESM) 诞生，浏览器开始逐步支持 ESM。在 Node.js 支持 ESM 之前，就有 Babel 这样的编译工具和 Webpack 这样的打包工具，将规范的 ESM 模块机制编译成 Node.js 的 CJS 模块机制了。随后，在Node.js v13.2.0 也开始引入了规范的 ESM 机制，同时兼容早期 CJS。\n所以我们现在写 Node.js 模块的时候，有 3 种思路：\n直接采用 ESM，在 Node.js v13.2.0 之后的版本可行。 使用 ESM，但是通过 Babel 编译成 CJS。 使用 CJS，Node.js 在未来很长一段时间还是会同时兼容 ESM 和 CJS 的。 ES Modules export 导出， import 导入\n导出语法 exporting declaration 导出声明\nexport let a, b export const a = 1, b = 2 export function functionName () {} export class ClassName {} export const { a, b } = obj export const [ a, b ] = arr 例如：\n// hello.mjs export const name = 'River' // index.mjs import { name } from './hello.mjs' export list 导出列表\nexport { name1, name2 } export { variable1 as name1, variable2 as name2 } export { variable1 as 'string name' } export { name1 as default } 例如：\n// hello.mjs const name = 'River' const sayHello = (text) =\u003e `Hello ${text}!` export { name, sayHello as default } // index.mjs import { name } from './hello.mjs' import sayHello from './hello.mjs' console.log(sayHello(name)) // Hello River! default exports 默认导出\nexport default expression export default function functionName() {} export default class ClassName {} 此外，还有 export ... from ...的聚合语法，在此不做赘述，要想了解可以看 MDN-JavaScript-export。\n导入语法 基于上述的 export 导出方式可以知道，export 导出的 API 分为 default 和 非 default。总结一下，针对这两种 API，import 也有两种不同的导入方式（可查看上述例子）：\nimport { API } from 模块路径 // 非 default API import defaultAPI from 模块路径 // default API 当然，和 export 一样，import 也可以使用 as 给 API 重命名。\nimport { variable1 as name1 } from 模块路径 import * as foo from 模块路径 上述的 import * as foo 可以将导出 API 生成对象 foo，并且 default API 为 foo.default。\n文件名后缀 需要注意的是，在 Node.js 中默认使用 CommonJS 规范定义 .js 文件的模块，用 ES Modules 规范定义 .mjs 文件的模块。关于这两者的启用规则，详细可查看 nodejs doc，在此不做赘述。\n如果要使用 ESM 定义 .js 文件的模块，可以在配置文件 package.json 中设置 type: module。\nCommonJS module.exports 导出，require 导入\n导出语法 module.exports module.exports = { name1, name2 } module.exports = { name1: variable1, name2: variable2 } // 不同于 ES Module 的 as 用法 exports exports.a = 1 exports.b = 2 exports.functionName = () =\u003e a + b 例如：\n// hello.js const name = 'River' const sayHello = (text) =\u003e `Hello ${text}!` module.exports = { name, sayHello } // index.js const { name, sayHello } = require('./hello.js') console.log(sayHello(name)) exports.属性名 是早期用法，现在应该尽量使用 module.exports = { 属性名 }。注意，两种语法不能同时使用，因为 exports.属性名 会被 module.exports = { 属性名 } 覆盖。\n导入语法 const { API } = require(模块路径) ESM 和 CJS 的差异 加载机制是理解这两个模块系统核心特性的关键，也是它们根本的区别所在。\nCJS 动态加载 运行时加载。模块依赖关系在代码执行时解析。这意味着 require() 函数调用是在代码执行过程中处理的，可以灵活使用模版字符串动态拼接路径，例如： const libPath = ENV.supportES6 ? './es6/' : './' const myLib = require(`${libPath}lib.js`) 还可以根据程序的运行逻辑和条件来加载模块。例如，可以在 if 中调用 require()，根据不同的条件加载不同的模块。 let api; if(condition) { api = require('./foo'); } else { api = require('./bar'); } 同步加载。在不需要考虑网络延迟的情况下，尤其是服务器端 JavaScript(Node.js)，模块一般都是从本地文件系统中加载，此时同步加载是可行的。 ESM 静态加载 编译时加载。模块依赖关系在编译时就确定。import 和 export 都必须放在最外层，不能被包含在函数或条件语句内。 异步加载。异步加载允许代码在模块下载和处理期间继续执行，解决了阻塞问题，当然也使模块管理更加复杂。 ESM 实现动态加载 ESM 不允许 import 语句用动态路径，也不允许在语句块中使用，但允许通过使用 import() 函数实现动态加载，而且是异步进行的。\n动态的 import() 返回一个 Promise，该 Promise 解析为引入模块的所有导出。需要使用 .then()、async/await 等方式来处理导入的模块。例如：\n(async function() { const { functionName } = await import('./myModules.mjs) functionName() }()) 使用场景：\n条件加载 例如： if(someCondition) { import('./myModules.mjs') .then(module =\u003e { module.functionName() }) } 性能优化。比如在处理大型模块时，通过代码分割和懒加载，减少应用的初始负载时间，提升性能。 ESM 向下兼容 在 Node.js 环境中，ES Modules 会向下兼容 CommonJS，对于 CJS 导出的 API，也可以使用 import() 引入，并且只能以 default 方式引入。例如：\n// foo.js const a = 1 const b = 2 const c = () =\u003e a + b module.exports = { a, b, c } // bar.mjs import abc from './foo.js' console.log(abc.a, abc.b, abc.c()) // 1, 2, 3 也就是说，module.exports 相当于：\nconst abc = { a, b, c } export default abc ","esm-和-cjs-的差异#\u003ccode\u003eESM\u003c/code\u003e 和 \u003ccode\u003eCJS\u003c/code\u003e 的差异":"","模块化及其优势#模块化及其优势":""},"title":"模块管理"},"/mysql/":{"data":{"error-1819-hy000-your-password-does-not-satisfy-the-current-policy-requirements#ERROR 1819 (HY000): Your password does not satisfy the current policy requirements":"运行下方代码会报错\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'admin' 错误信息：ERROR 1819 (HY000): Your password does not satisfy the current policy requirements。密码不符合安全要求，改下密码的安全要求就可以了。解决步骤：\n登录 MySQL\nmysql -u root -p 检查当前密码策略\nSHOW VARIABLES LIKE 'validate_password%'; +-------------------------------------------------+--------+ | Variable_name | Value | +-------------------------------------------------+--------+ | validate_password.changed_characters_percentage | 0 | | validate_password.check_user_name | ON | | validate_password.dictionary_file | | | validate_password.length | 8 | | validate_password.mixed_case_count | 1 | | validate_password.number_count | 1 | | validate_password.policy | MEDIUM | | validate_password.special_char_count | 1 | +-------------------------------------------------+--------+ 修改当前密码策略\nSET GLOBAL validate_password.length=4; SET GLOBAL validate_password.policy=LOW; 现在密码策略已经修改了\n+-------------------------------------------------+-------+ | Variable_name | Value | +-------------------------------------------------+-------+ | validate_password.changed_characters_percentage | 0 | | validate_password.check_user_name | ON | | validate_password.dictionary_file | | | validate_password.length | 4 | | validate_password.mixed_case_count | 1 | | validate_password.number_count | 1 | | validate_password.policy | LOW | | validate_password.special_char_count | 1 | +-------------------------------------------------+-------+ 刷新权限并再次尝试修改密码\nFLUSH PRIVILEGES ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'admin'; ","mysql安装和使用#MySQL安装和使用":"MySQL安装和使用","命令行工具#命令行工具":"全部命令行请查看官方文档：mysql Client Commands\n下面列举几种常用的：\n\\g 和 \\G 都是命令的结束符，除此之外，也可以直接使用 ; 来结束命令。\n\\g # 将命令发送到 MySQL 服务器 \\G # 将命令发送到 MySQL 服务器，并且格式化输出 \\c # 清除当前输入 \\q # 退出 MySQL ","基础使用#基础使用":"连接 MySQL mysql -u root -p Enter password:****** 基本命令 查看数据库列表 SHOW DATABASES; 创建数据库 CREATE DATABASE testdb; 使用数据库 USE testdb; 创建表 CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(100), email VARCHAR(100) ); 查看表结构 DESCRIBE users; 数据操作 插入数据 INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com'); 查询数据 SELECT * FROM users; 更新数据 UPDATE users SET email = 'john.doe@example.com' WHERE name = 'John Doe'; 删除数据 DELETE FROM users WHERE name = 'John Doe'; 常用功能 条件查询 SELECT * FROM users WHERE email LIKE '%@example.com'; 排序查询 SELECT * FROM users ORDER BY name ASC; 聚合函数 SELECT COUNT(*) FROM users; SELECT AVG(id) FROM users; 多表操作 创建第二个表 CREATE TABLE orders ( order_id INT AUTO_INCREMENT PRIMARY KEY, user_id INT, product_name VARCHAR(100), FOREIGN KEY (user_id) REFERENCES users(id) ); 连接查询 SELECT users.name, orders.product_name FROM users JOIN orders ON users.id = orders.user_id; SELECT users.name, orders.product_name 子句指定我们希望从数据库中提取的列，这里会提取到两个列：\nusers 表中的 name 列(users.name) orders 表中的 product_name 列(orders.product.name) FROM users 子句指定我们查询的第一个表，即 users 表。 JOIN orders ON users.id = orders.user_id 子句用于将两个表连接起来。即使用内连接(INNER JOIN)将 users 表和 orders 表关联起来。连接条件是 users.id = orders.user_id。 内连接(INNER JOIN)会返回两个表中满足条件的所有记录。如果一条记录在 users 表和 orders 表中都有对应的匹配记录，那么这条记录会被包括在结果集中。简单来说，这个查询会返回所有有订单的用户及其订单的产品名称。\n举个例子，假如有以下两个表：\nusers 表：\nid name 1 Alice 2 Bob 3 Charlie orders 表：\norder_id user_id product_name 101 1 Laptop 102 1 SmartPhone 103 2 Tablet 执行上述 SQL 语句后，查询结果是：\nname product_name Alice Laptop Alice Smartphone Bob Tablet ","安装#安装":"MySQL Community Server MySQL Community Server 是数据库服务器，它负责实际存储和管理数据。\n下载地址：https://dev.mysql.com/downloads/mysql/\n选择版本和操作系统，点击 Download 按钮下载。我是 macOS 14 系统，M1 芯片，这里就选择了 macOS 14 (ARM, 64-bit), DMG Archive 下载。\n安装完成后，打开系统设置，拉到最下方就能看到 MySQL，点击按钮运行 MySQL 服务。\nMySQL Workbench MySQL Workbench 是一个客户端应用程序，你可以用它来连接到 MySQL Community Server，进行数据库设计、开发和管理等操作。\n要注意版本保持一致，下载地址：https://dev.mysql.com/downloads/workbench/\n安装后打开，点击 Connection 或者新建一个，输入密码就OK了。","常见问题#常见问题":"","环境变量#环境变量":"查看当前 shell\necho $SHELL 如果是 /bin/bash，说明用的是 bash，如果是 /bin/zsh，说明用的是 zsh。\n如果是 bash:\n# 1. 更改 vim ~/.bash_profile # 2. 添加 export PATH=${PATH}:/usr/local/mysql/bin # 3. 更新 source ~/.bash_profile 如果是 zsh：\n# 1. 更改 vim ~/.zshrc # 2. 添加 export PATH=${PATH}:/usr/local/mysql/bin # 3. 更新 source ~/.zshrc ","用-mysql-workbench-新建-table-时没有-apply-按钮#用 mysql workbench 新建 table 时没有 apply 按钮":"8.0.36 版本有问题，替换成 8.0.34 就正常使用了。","进入-mysql-cli#进入 MySQL CLI":" mysql -u root -p 输入安装时密码，即可成功进入 MySQL CLI。"},"title":"MySQL 安装和基础使用"},"/npm/":{"data":{"":"","npm#NPM":"NPM NPM 是 Node.js 自带的包管理工具。\nNode.js 的模块大致分为内部模块和其他模块。内部模块是 Node.js 内部集成的模块，不需要引用 JS 外部文件，而是通过 require 或 import 模块名引入。\n比如内置 fs 模块（文件操作相关的模块），可以这样引入：\nconst fs = require('fs') 除了上图这些内置模块外，在开发中还会使用很多其他模块，有两种方式可以引入：\n通过文件路径引入\n例如，在下面这个项目中，想要在 b 目录下的 bar.js 中引入 a 目录下的 foo.js。\n- a foo.js - b bar.js 可以在 bar.js 里这样引入：\nconst foo = require('../a/foo.js') 通过 NPM 将模块安装到项目中(默认是 node_modules 目录)，在代码中用包名来引用模块。\nnpm registry 是 NPM 的官方仓库，可查找需要的包，并按照包文档的指引进行安装使用。\n比如，dayjs 这个插件，使用 NPM 安装：\nnpm install dayjs 使用：\nconst dayjs = require('dayjs') dayjs().format() 当通过包名引入模块时，Node.js 会根据 resolve 算法先搜索模块所在的目录下的 node_modules，如果没找到，会递归查找上级目录中的 node_modules，直到根目录。\nNPM 值得讲的很多，以后会单独开个专题✍️。"},"title":"NPM"},"/personal-rss-feed-recommendations/":{"data":{"":"","#":"作为一个多年使用 RSS 阅读的人来说，RSS 是我每天了解最新的科技、技术、时事的主要渠道之一。\n这篇文章会推荐一些我认为不错的订阅，不管你刚上手 RSS 或者想丰富自己的订阅库，都可以参考一下我的 List。\n科技 中文 极客公园\n阮一峰的网络日志\n1Link.Fun\nSuperTechFans：每天用 AI 总结 Hacker News 的 Top 10 文章\n英文 tldr.tech：Too long don’t read，每日发送几则科技文章摘要\nthe DONUT：不止科技消息，涵盖很多\n技术 中文 山月前端周刊\n掘金前端本周最热\n美团技术团队\n值得一读技术博客\n前端食堂\n英文 Frontend Focus\nWeb.dev\nChangelog News\nJavaScript Weekly\nNode Weekly\n推荐的不多，也希望大家不要一次性订阅太多。因为我经历过一股脑订阅大量 newsletter，一天接收几百个推送，最后结果是压根不会打开去阅读，从订阅到放弃。希望大家在精不在多，这也避免了长期沉浸在 RSS 阅读而导致的信息茧房。\n除此之外，我最近在使用的阅读工具是 Readwise Reader，使用体验及其舒适，强烈推荐，后续我也会写专门一篇文章来介绍下这个优秀的 Web 应用。"},"title":"个人向的 RSS 订阅推荐"},"/pre-knowledge-of-nodejs/":{"data":{"":"","nodejs-是-javascript-运行时环境#Node.js 是 JavaScript 运行时环境":"Node.js 是 JavaScript 运行时环境 Node.js® is an open-source, cross-platform JavaScript runtime environment.引用来源：Node.js\nNode.js 并不是一种语言而是一个平台，是 JavaScript 的运行时环境(runtime environment)/宿主环境(host environment)。\n讨论 Node.js 就不得不提到 Chrome V8 引擎。09年，谷歌开始研发 Chrome 浏览器，这也是现今使用最为广泛的浏览器，由 Lars Bak 领导开发的 Chrome V8 引擎也相应问世，JavaScript 就此展开了一场性能革命，Node.js 就是基于 Chrome V8 引擎构建的。随后，Node.js 的作者 Ryan Dahl 还构建了 Deno。\n如今，JavaScript 的层级架构也基本趋于稳定，如图：\n图片来源：掘金小册\n最下面的层级是脚本语言规范(Spec)，ECMAScript。 再往上一层是语言实现，JavaScript、JScript、ActionScript 等都是对 ECMAScript 的语言实现。 到了引擎层面，除了上文提到的 Chrome V8 外，还有 SpiderMonkey、QuickJS、JerryScript 等常见引擎。 最上面是运行时环境，基于 Chrome V8 封装的运行时环境有 Node.js、Chromium、Deno、CloudFlare Workers，Firefox 是基于 SpiderMonkey 封装的运行时环境。 ","使用场景#使用场景":" 服务端\nNode.js 提供了基于事件驱动和非阻塞的接口，可用于编写高并发状态下的程序，而且 JavaScript 的匿名函数、闭包、回调函数等特性就是为事件驱动而设计的。\nNode.js 一些内置模块如 http、net、fs，就是为服务端设计的。无论是 HTTP，还是 TCP、UDP，又或是 RPC 服务，Node.js 都可以胜任。\n桌面端\nElectron.js，由OpenJS基金会开发和维护的自由开源软件框架。该框架旨在使用Chromium浏览器引擎版本和使用Node.js运行时环境的后端渲染的网络技术创建桌面应用程序。\nVisual Studio Code、1Password、钉钉等软件，都是基于 Electron 开发的。\n端游\n除了通过 WebGL 在浏览器里写前端页面上的游戏、通过 Electron 封装成看起来像端游的游戏外，JavaScript 还能通过 Node.js 的 binding 去使用 OpenGL 甚至 DirectX 去写货真价实的桌面游戏。\n机器学习\npipcook\nNode.js 最早被设想为一种用于构建服务端应用的技术，但作为运行在操作系统中的 JavaScript 运行时环境，它已经成为了一个平台，可适配领域涵盖了泛前端和后端，传统服务和 Serverless，工具、商业、游戏等等。","基本架构#基本架构":" 图片来源：medium.com\nNode.js 是运行在操作系统之上的，底层由 Chrome V8 引擎和一些 C/C++ 写的库构成，比如 libUv、c-ares、llhttp/http-parser、open-ssl、zlib等。其中，libUV 负责处理事件循环，c-ares、llhttp/http-parser、open-ssl、zlib 等库提供 DNS 解析、HTTP 协议、HTTPS 和文件压缩等功能。\n中间层由 Node.js Bindings、Node.js Standard Library 和 C/C++ AddOns 构成。Node.js Bindings 层的作用是将底层那些用 C/C++ 写的库接口暴露给 JS 环境，而 Node.js Standard Library 是 Node.js 本身的核心模块。至于 C/C++ AddOns，它可以让用户自己的 C/C++ 模块通过桥接的方式提供给Node.js。\n再上一层是 Node.js 的 API 层，我们使用 Node.js 开发应用，主要使用的就是 API 层，Node.js 应用最终运行在 API 层之上。"},"title":"Node.js 前置知识"},"/understand-vue-next-tick/":{"data":{"":"nextTick 是 Vue 提供的方法，用于在下一次 DOM 更新循环结束后执行延迟回调，主要用于获取更新后的 DOM 状态。因为 Vue 在更新 DOM 时是异步执行的，因此在数据变化后，视图不会立即更新，会把所有的 DOM 更新操作放入到一个队列中，等下一次事件循环(event loop)结束后统一执行。\nnextTick 的实现依赖于 event loop 机制，如果你不知道 event loop，可以先看我这篇文章了解下 JavaScript 中的 Event Loop。","nexttick-使用方法场景#nextTick 使用方法、场景":"Vue 提供了 nextTick 的全局 API，在 Vue2 中可以直接通过 this.$nextTick() 调用，在 Vue3 中，nextTick 作为一个独立函数，可以直接从 Vue 包中导入并使用。\n// vue2 this.$nextTick(() =\u003e { // ... }) // vue3 import { nextTick } from 'vue'; nextTick(() =\u003e { // ... }) nextTick 主要用于获取更新后的 DOM 状态，异步操作 DOM，下面是常见的使用场景：\n修改数据后需要立即获取 DOM this.message = 'updated message' this.$nextTick(() =\u003e { console.log('message', this.$el.textContent) }) 也可以与 Promise 结合使用 async updateMessage() { this.message = 'updated message' await this.$nextTick() console.log('message', this.$el.textContent) } 在生命周期钩子中进行 DOM 操作 在 created() 钩子中，DOM 尚未渲染完毕，因此任何 DOM 操作都可能无效。将这些操作放在 nextTick() 中以确保在 DOM 渲染后执行。","nexttick-实现#nextTick 实现":"nextTick 核心实现思路：\n队列机制\nnextTick 的回调函数会被放到一个任务队列，不会立即执行。当 DOM 更新完后，队列中的任务会被一次性执行。\n优先使用微任务\nvue2 会先优先使用 Promise (微任务)，同时也做了降级处理，用来适配更多浏览器，这个下文会详细说。 vue3 默认浏览器支持 Promise(微任务)。\nVue2 优雅降级 伪代码：\nlet callbacks = [] // 任务队列，存储通过 nextTick 提交的回调函数 let pending = false // 标志位，防止重复启动任务调度 // 用于执行当前任务队列中的所有回调 function flushCallbacks() { pending = false // 清除标志，表示任务已被执行 const copies = callbacks.splice(0) // 复制当前任务队列 callbacks.length = 0 // 清空任务队列 for (let cb of copies) { cb() // 执行每个回调 } } let timerFunc // 动态分配的调度函数，根据不同的运行环境选择不同的实现方式，宏任务或微任务 if(typeof Promise !== 'undefined') { // 优先使用 Promise，创建微任务 timerFunc = () =\u003e Promise.resolve().then(flushCallbacks) } else if(typeof MutationObserver !== 'undefined') { // 回退到 MutationObserver，通过监听 DOM 变化触发回调，创建微任务 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode('') // 创建一个伪 DOM 节点 observer.observe(textNode, {characterData: true}) timerFunc = () =\u003e { textNode.data = String(Math.random()) // 每次改变其内容时触发回调 } } else if(typeof setImmediate !== 'undefined') { // 回退到 setImmediate，创建宏任务 timerFunc = () =\u003e setImmediate(flushCallbacks) // 如果环境支持 setImmediate(edge 和 IE) } else { // 最终回退到 setTimeout timerFunc = () =\u003e setTimeout(flushCallbacks, 0) } export function nextTick(cb, ctx) { callbacks.push(() =\u003e { if(cb) { cb.call(ctx) // 确保回调的上下文绑定 } }) if(!pending) { pending = true // 标记为已调度 timerFunc() // 调用调度方法 } } vue2 的调度机制优先级如下：\nPromise 微任务 MutationObserver 微任务 setImmediate 宏任务(仅edge、IE支持) setTimeout 宏任务 Vue3 Promise 与 vue2 相比，vue3 更加简洁和现代化，完全依赖于 Promise 微任务机制。\n伪代码：\n// 创建一个状态为 fulfilled 的 Promise实例 // 用于调度微任务，在同步代码执行完成后立即进行微任务队列 const resolvedPromise = Promise.resolve() // 用来跟踪当前是否有正在进行的刷新操作 // 如果存在未完成的刷新任务，nextTick 会返回相同的 Promise，以确保回调在适当的时机执行 let currentFlushPromise: Promise\u003cvoid\u003e | null = null export function nextTick\u003cT = void\u003e(this: T, fn?: (this: T) =\u003e void): Promise\u003cvoid\u003e { // fn 是可选的回调函数 const p = currentFlushPromise || resolvedPromise // 如果当前有未完成的刷新任务，使用这个 Promise，否则使用 resolvedPromise return fn ? p.then(() =\u003e fn.call(this)) : p // 如果传入了回调函数 fn，通过 Promise 调用它，否则仅返回 Promise } "},"title":"理解 Vue.js nextTick"},"/vue-reactivity-source-code-review/":{"data":{"":"","vue2-响应式原理#Vue2 响应式原理":"在 Vue2 中，当一个 JavaScript 对象传入 Vue 实例作为 data 选项时，Vue 会遍历此对象所有的 property，并使用 Object.defineProperty() 把这些 property 转为 getter/setter。在 getter 中收集依赖，在 setter 中触发更新：每个组件实例都对应一个 watcher 实例，它会在组件的渲染过程中把接触过的数据 property 记录为依赖，当依赖项的 setter 触发时，会去通知 watcher，从而使他关联的组件重新渲染。这就是 Vue2 响应式实现的思路，至于具体是如何实现的，下文将会展开分析。\nObject.defineProperty() Object.defineProperty() 是 Vue 实现响应式的基础，它允许精确地添加或修改对象上的属性，语法如下：\nObject.defineProperty(obj, prop, descriptor) 参数： obj: 要定义属性的对象 prop: 要定义或修改的属性名 descriptor: 要定义或修改的属性描述符\ndescriptor 常用属性：\nenumerable：属性是否可枚举，默认为 false configurable：属性是否可被修改或删除，默认为 false get：获取属性的方法 set：设置属性的方法 参考：MDN-Object.defineProperty()\n实现响应式 在 Vue 源码中，通过 defineReactive 函数对 Object.defineProperty 进行封装,实现响应式。get 会触发 reactiveGetter 实现依赖收集，set 会触发 reactiveSetter 通知依赖更新。下面是这个函数的源码的简化版本，只需要看非注释部分：\n参数：\nobj（需要绑定的对象） key（对象的属性名） val（具体的值） function defineReactive(obj, key, val) { // 创建依赖收集器 // const dep = new Dep() Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter() { // 依赖收集 // if (Dep.target) { // dep.depend() // } return val }, set: function reactiveSetter(newVal) { if (newVal === val) return val = newVal // 通知所有依赖 // dep.notify() } }) } 在本篇文章开头提到，Vue 会遍历对象的所有属性property，所以现在还需要再封装一层 Observer 去遍历对象，将一个普通 JavaScript 对象的所有属性转换成响应式的。简化版本如下：\nclass Observer { constructor(value) { // 给被观察的对象添加 __ob__ 属性，指向这个 Observer 实例 def(value, '__ob__', this) if(Array.isArray(value)) { // 劫持数组方法 // ... // 处理数组 this.observeArray() } else { // 处理对象 const keys = Object.keys(value) for (let i = 0; i \u003c keys.length; i++) { const key = keys[i] defineReactive(value, key, NO_INITIAL_VALUE, undefined, shallow, mock) } } } observeArray(value) { for (let i = 0, l = value.length; i \u003c l; i++) { observe(value[i], false, this.mock) } } } 其中，def() 是一个工具函数，用来给对象添加属性：\nexport function def(obj, key, val) { Object.defineProperty(obj, key, { value: val, }) } observe() 是入口函数，会返回 Observer 实例：\nfunction observe(value) { if (typeof value !== 'object') return let ob if (hasOwn(value, '__ob__') \u0026\u0026 value.__ob__ instanceof Observer) { ob = value.__ob__ } else { ob = new Observer(value) } return ob } 依赖收集 刚才 defineReactive 中被注释掉的几行代码，也就是下文中高亮的部分：在 get 时进行依赖收集，在 set 时通知所有依赖，这是实现响应式系统的另一个重要部分——依赖收集。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function defineReactive(obj, key, val) { // 创建依赖收集器 const dep = new Dep() Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter() { // 依赖收集 if (Dep.target) { dep.depend() } return val }, set: function reactiveSetter(newVal) { if (newVal === val) return val = newVal // 通知所有依赖 dep.notify() } }) } 为什么需要依赖收集 举个例子，现在有这么个 Vue 对象：\nnew Vue({ template:` \u003cdiv\u003e \u003cspan\u003e{{ text1 }}\u003c/span\u003e \u003cspan\u003e{{ text2 }}\u003c/span\u003e \u003c/div\u003e `, data: { text1: 'text1', text2: 'text2', text3: 'text3', } }) 要对 text3 进行修改：\ndata.text3 = 'text3 modify' 虽然修改了 data 中 text3 的值，但是由于模板渲染中并没有用到 text3，所以并不会触发上文中的 dep.notify() 去通知依赖、更新视图。\n再举个例子，假如现在有个全局对象，而且我们在两个 Vue 对象中使用了它。\nlet globalObj = { text1: 'text1' } let o1 = new Vue({ template:` \u003cdiv\u003e\u003cspan\u003e{{ globalObj.text1 }}\u003c/span\u003e\u003c/div\u003e `, data: { globalObj } }) let o2 = new Vue({ template:` \u003cdiv\u003e\u003cspan\u003e{{ globalObj.text1 }}\u003c/span\u003e\u003c/div\u003e `, data: { globalObj } }) 这个时候修改 globalObj.text1 的值：\nglobalObj.text1 = 'text1 modify' 在响应式系统中，当 globalObj.text1 的值变化，应该通知 o1、o2 这两个 vm 实例去更新视图。依赖收集就是来实现这个的：依赖收集会让这个数据(globalObj.text1)知道，有两个地方(o1、o2)依赖自身，所以当这个数据(globalObj.text1)变化时，会去通知依赖自身的 o1、o2。\n依赖收集的核心 —— Dep 和 Watcher 让我们回归代码，看看具体是如何实现依赖收集的。\n首先需要一个 Dep，每个 Dep 实例有一个数组去存放 watchers，当数据变化时会通知 watchers 更新。同样的，每个 Watcher 实例也有一个数组去存放它依赖的 deps。也就是说，依赖收集是双向的，Dep 记录 Watcher，Watcher 也记录 Dep，这个很重要。\n先看看 Dep：\nclass Dep { static target // 静态属性，全局唯一的当前正在执行的 Watcher id // 实例属性，每个 dep 的唯一标识 subs // 实例属性，存储所有订阅者 constructor { this.id = uid++ this.subs = [] } // 添加订阅者 addSub(sub) { this.subs.push(sub) } // 移除订阅者 removeSub(sub) { remove(this.subs, sub) } // 建立依赖关系 depend() { if(Dep.target) { // 如果有正在执行的 Watcher，将这个 Watcher 作为依赖 Dep.target.addDep(this) } } // 通知所有订阅者 notify() { for(let i = 0, l = this.subs.length; i \u003c l; i++) { this.subs[i].update() } } } Dep.target = null; 如上所述，class Dep 的 target 作为静态属性，用来记录当前唯一正在执行的 Watcher，id 用来给 Dep 实例添加唯一标识，subs 用来存储所有订阅者。addSub() 和 removeSub() 用来添加订阅者、移除订阅者，depend() 用来建立依赖关系，notify() 用来通知所有的订阅者。\nWatcher 会复杂一点，让我们来看一下：\nclass Watcher { constructor (vm, expOrFn, cb, options={}) { if(options) { this.lazy = !!this.lazy this.sync = !!this.sync } this.vm = vm // Vue 实例 this.cb = cb // 回调函数 this.deps = [] // 存储该 watcher 依赖的所有 dep this.newDeps = [] // 新一轮依赖收集的 dep this.depIds = new Set() // 依赖的id集合，用于去重 this.newDepIds = new Set() // 新依赖收集的id集合 this.expression = expOrFn.toString() // 用于调试 this.dirty = this.lazy this.id = ++uid // 唯一标识 // 这里定义了 getter if(typeof expOrFn === 'function') { this.getter = expOrFn // 如果 expOrFn 是函数，直接作为 getter } else { this.getter = parsePath(expOrFn) // 如果是字符串，转换成获取对象属性的函数 } // 立即执行一次 getter，进行初始化和依赖收集 this.value = this.lazy ? undefined : this.get() } get() { pushTarget(this) // 将当前 watcher 设置为全局活动的 watcher let value try { // 执行 getter，触发被观察对象的 getter，从而收集依赖 value = this.getter.call(this.vm, this.vm) } catch (e) { throw e } finally { popTarget() // 恢复之前活动的watcher this.cleanupDeps() // 清理依赖 } return value } addDep(dep) { const id = dep.id // 检查是否已在新的依赖集合中 if(!this.newDepIds.has(id)) { // 添加到新的依赖 id 集合中 this.newDepIds.add(id) // 添加到新的依赖数组中 this.newDeps.push(dep) // 检查是否在旧依赖中 if(!this.depIds.has(id)) { // 如果不在旧依赖中，让 dep 去收集当前 watcher dep.addSub(this) } } } // 清理依赖 cleanupDeps() { let i = this.deps.length // 遍历旧依赖数组 while (i--) { const dep = this.deps[i] // 如果新依赖数组中不包含这个旧依赖 if (!this.newDepIds.has(dep.id)) { // 将这个 watcher 从 dep 中移除 dep.removeSub(this) } } // depIds 更新，清空 newDepIds let tmp: any = this.depIds this.depIds = this.newDepIds this.newDepIds = tmp this.newDepIds.clear() // deps 更新，清空 newDeps tmp = this.deps this.deps = this.newDeps this.newDeps = tmp this.newDeps.length = 0 } update() { // lazy 模式，懒计算，不会立即重新计算，只是将 dirty 标记为 true if (this.lazy) { this.dirty = true } else if (this.sync) { // sync 模式，同步更新模式，立即更新 this.run() } else { // 默认异步更新模式，将 watcher 放入更新队列 queueWatcher(this) } } run() { const value = this.get() // 获取新的值 if(value !== this.value || isObject(value) || this.deep) { // 如果新旧值不相等 | 新值是对象 | 深度监听 const oldValue = this.value // 保存旧值 this.value = value // 设置新值 this.cb.call(this.vm, value, oldValue) // 执行回调函数，并传入新值和旧值 } } } 在 Watcher 的 constructor 中，会先处理传入的 expOrFn，当它是函数时，会直接赋给 getter，如果是字符串，那么还需要 parsePath 来转为访问函数，例如 parsePath('user.name') 会返回函数：(obj) =\u003e obj['user']['name']，注意此处 obj 就是 getter.call 中调用到的 vm，也就是当前 Vue 实例。此外还会立即执行一次 getter()，进行初始化和依赖收集。\n看下面的代码，为了处理嵌套的 Watcher 场景，在 getter() 开始时，会将当前 Watcher 也就是 target 推入 targetStack 栈中，并将 Dep.target 指向当前 Watcher，待 getter() 结束时，又会将这个 Watcher 从栈中弹出，将 Dep.target 的指向修改为上一个 Watcher。\nconst targetStack = [] export function pushTarget(target) { targetStack.push(target) Dep.target = target } export function popTarget() { targetStack.pop() Dep.target = targetStack[targetStack.length - 1] } 而 Watcher 的 addDep 方法，和 Dep 中的 addSub 方法互相调用，做双向依赖收集的处理，不用担心死循环的问题，因为 Watcher 还有一个 cleanupDeps 来及时的清理依赖。\nupdate() 和 dep() 则负责更新处理，当数据变化时执行相应的操作。先看 update()，在数据变化时，它有三种处理方式：\nlazy 模式\nif(this.lazy) { this.dirty = true } 在源码中搜索 dirty 可以找到 evaluate() 方法：\n/** * Evaluate the value of the watcher. * This only gets called for lazy watchers. */ evaluate() { this.value = this.get() this.dirty = false } 当 evaluate() 被调用时，会调用 get() 方法，并将 dirty 设为 false。那么 evaluate() 又在哪里被使用呢？ 全局搜素后，能看到在 state.ts 文件中被调用：\nfunction createComputedGetter(key) { return function computedGetter() { const watcher = this._computedWatchers \u0026\u0026 this._computedWatchers[key] if (watcher) { if (watcher.dirty) { watcher.evaluate() } if (Dep.target) { // ... watcher.depend() } return watcher.value } } } 也就是说，当 computed 的 getter() 被调用时，如果这个 watcher 是脏数据(dirty 为 true)，那么就会执行 evaluate()，使用 lazy 模式不会立即重新计算值，只是将 dirty 标记为 true，等到下次访问这个属性时才会真正计算。 计算属性 computed 就是采用这个模式。\nsync 模式\nelse if(this.sync) { this.run() } 如果是 sync 模式，会调用 run()：\nrun() { const value = this.get() // 获取新的值 if(value !== this.value || isObject(value) || this.deep) { // 如果新旧值不相等 | 新值是对象 | 深度监听 const oldValue = this.value // 保存旧值 this.value = value // 设置新值 this.cb.call(this.vm, value, oldValue) // 执行回调函数，并传入新值和旧值 } } 能够看到，run 方法会立即执行 get()，并且如果新旧值不相等或新值是对象或深度监听的时候，会执行回调函数，并传入新值和旧值。 所以 sync 模式主要是用于需要立即响应数据变化的场景，不过 sync 默认是 false，大多数情况都会使用 async 异步更新。\nqueue 异步更新\nelse { queueWatcher(this) } 看下 queueWatcher() 做了些什么：\nlet has = {} /** * Push a watcher into the watcher queue. * Jobs with duplicate IDs will be skipped unless it's * pushed when the queue is being flushed. */ export function queueWatcher(watcher: Watcher) { // 重复检查，防止同一个 watcher 被重复添加到队列中 const id = watcher.id if (has[id] != null) { return } // 防止 watcher 在自己的更新过程中触发自己的递归更新 if (watcher === Dep.target \u0026\u0026 watcher.noRecurse) { return } has[id] = true if (!flushing) { // 如果队列还没有开始刷新，推入队列 queue.push(watcher) } else { // 如果队列正在刷新，需要按照 id 顺序插入 // 确保 watcher 按照创建顺序(id大小)执行，因为：1.父组件的 watcher 要在子组件之前更新 2.computed 要在普通 watcher 之前更新 let i = queue.length - 1 while (i \u003e index \u0026\u0026 queue[i].id \u003e watcher.id) { i-- } queue.splice(i + 1, 0, watcher) } // queue the flush if (!waiting) { waiting = true // 确保队列会在下一个 tick 被刷新， nextTick(flushSchedulerQueue) } } 当 flushSchedulerQueue 被执行时，flushing 会被设置为 true。 通过 nextTick() 调用 flushSchedulerQueue()，在下一个微任务中执行 flushSchedulerQueue()，这样多次修改数据，只会触发一次更新。 Vue 响应式系统 通过上面的章节我们知道，Vue 的响应式系统的实现，靠的是数据响应式化以及依赖收集。数据响应式化的核心/原理是 Object.defineProperty，它会注册 get 和 set 进行依赖收集，具体是在响应式对象中 new 一个 Dep 实例来进行依赖收集的处理，将当前的 Watcher 添加到 Dep 实例的订阅者列表(subs)中。那么其实到这里，对于整个响应式系统构建的流程还是有一些模糊的，尤其是 new Watcher()的时机，所以当新建一个 Vue 实例时，上面所述的这些处理都是何时进行的呢？\n首先我们要知道 Vue 实例中有哪些 Watcher。作为 Vue 用户经常能够接触到的无非就是渲染 Watcher(Render Watcher)、计算属性 Watcher(Computed Watcher)和用户 Watcher(User Watcher)：\n// 模板渲染 Render Watcher \u003cdiv\u003e{{ message }}\u003c/div\u003e // computed 选项，Computed Watcher computed: { total() { return this.price * this.quantity } } // watch 选项，User Watcher watch: { price(newVal, oldVal) { console.log('price change:', newVal) } } 现在我们不着急关注何时 new Watcher，先了解下 new Vue() 的整体流程:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 function initMixin(Vue) { Vue.prototype._init = function () { const vm = this // 初始化生命周期 initLifeCycle(vm) // 初始化事件 initEvent(vm) // 初始化渲染 initRender(vm) // 调用 beforeCreate Hook callHook(vm, 'beforeCreate') // 初始化 inject initInject(vm) // 初始化 state initState(vm) // 初始化 provide initProvide(vm) // 调用 created Hook callHook(vm, 'created') // 如果有 el 选项，自动挂载 if(vm.$options.el) { vm.$mount(vm.$options.el) // 创建 Render Watcher } } } 我们主要关注 initState 和 $mount。\ninitState initState 会依次初始化 props -\u003e methods -\u003e data -\u003e computed -\u003e watch：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function initState(vm) { const opts = vm.$options // 1. 初始化 props if (opts.props) initProps(vm, opts.props) // 2. 初始化 methods if (opts.methods) initMethods(vm, opts.methods) // 3. 初始化 data if (opts.data) { initData(vm) // 生成响应式对象 } // 4. 初始化 computed if (opts.computed) initComputed(vm, opts.computed) // 5. 初始化 watch if (opts.watch \u0026\u0026 opts.watch !== nativeWatch) { initWatch(vm, opts.watch) } } 生成响应式对象的过程，也就是前面提到的 Object.defineProperty，就是在 initData 中实现：\nfunction initData() { observe(data) // 上文中提到的生成响应式对象入口函数 } initComputed 和 initWatch 分别创建 Computed Watcher 和 User Watcher：\nfunction initComputed() { // 为每个计算属性创建 computed watcher new Watcher(vm, getter, null, options) } function initWatch() { // 为每个 watch 创建 user watcher new Watcher(vm, key, cb, options) } $mount Render Watcher 会在组件挂载时($mount)创建。\n// 创建渲染 watcher (mount 阶段) Vue.prototype.$mount = new Watcher(vm, updateComponent, null, options) ","vue2-响应式系统的缺陷#Vue2 响应式系统的缺陷":"Vue2 的响应式并不是完美的，Object.defineProperty 这种实现方式自带一些缺陷，所以在使用 Vue2 时需要注意这些问题。\n对象 Vue2 无法检测对象属性的添加和删除。\n例如：\nvar vm = new Vue({ data: { a: 1 } }) // vm.a 是响应式的 vm.b = 2 // vm.b 是非响应式的 因为 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转为响应式的。\nfunction initData(vm) { let data = vm.$options.data observe(data) // 在这里调用 observe, 使对象响应式化 } 解决方案1 Vue.set 对于已经创建的实例，虽然 Vue 不允许动态添加根级别的响应式 property。但是可以使用 Vue.set(object, propertyName, value) 的方法向嵌套对象添加响应式 property。\n例如在 data 中有这么一个对象：\nvar vm = new Vue({ data: { someObject: { a: 1, } } }) 使用 Vue.set 给 someObject 新增键名为 b 的响应式 property：\nVue.set(vm.someObject, 'b', 2) 或\nthis.$set(this.someObject, 'b', 2) 解决方案2 Object.assign 有时需要为已存在的对象赋值多个新 property，可以使用 Object.assign。\nthis.someObject = Object.assign({}, this.someObject, {a: 1, b: 2}) 但要注意，像下面这样新增的 property，是没有响应式的：\nObject.assign(this.someObject, {a: 1, b: 2}) 原因很简单，Object.assign(this.someObject,{a:1,b:2}) 这种写法相当于直接修改、添加属性：\n// 等同于 this.someObject.a = 1 // 触发 a 的 setter this.someObject.b = 2 // b 仍为非响应式 而 Object.assign({},this.someObject,{a:1,b:2}) 这种写法可以触发 someObject 的 setter，会递归遍历 someObject 上的所有属性，进行响应式转换。\n数组 Vue2 无法检测数组索引和长度变化。\n数组索引：vm.items[indexOfItem] = newValue 数组长度：vm.items.length = newLength 以上两种变化无法触发响应式更新，因为数组的索引实际上就是对象的属性，虽然理论上 Vue 可以像处理对象属性一样处理数组索引，但是数组过长时，比如一个10000长度的数组，如每个索引都设置 getter/setter，会有严重的性能问题。同样的，数组的 length 属性也没有做响应式处理，因为可能会引发连锁反应（修改 length 可能会影响大量素）。\nVue2 为了解决这个问题，重写了数组的七个方法，这七个方法可以触发响应式更新：\npush() pop() shift() unshift() splice() sort() reverse() 所以想要触发数组的响应式，应该这样做：\n// 修改数组索引 vm.items.splice(indexOfItem, 1, newValue) // 修改数组长度 vm.items.splice(2) 性能 Vue2 的响应式实现需要递归遍历对象的所有属性，本身性能开销就比较大，这也是 Vue3 改为通过 proxy 来实现响应式的原因。","vue3-针对响应式做的改进#Vue3 针对响应式做的改进":"proxy 实现响应式 Vue3 的响应式系统基于 ES6 的 proxy，是对于 Vue2 中 Object.defineProperty 的重大升级，优点有：\n可以检测对象属性的添加和删除 可以监听数组变化而无需额外处理 不需要深度递归遍历，性能更好 支持 Map、Set 等数据结构 function reactive(target) { return new Proxy(target, { get(target, key, receiver) { const res = Reflect.get(target, key, receiver) track(target, key) // 依赖收集 return res }, set(target, key, value, receiver) { const res = Reflect.set(target, key, value, receiver) trigger(target, key) // 触发更新 return res } }) } 这里的 Reflect 是一个内置对象，提供拦截 JavaScript 操作的方法。\nReflect.get(target, key) // 获取属性 Reflect.set(target, key, value) // 设置属性 Reflect.has(target, key) // 检查属性 Reflect.deleteProperty(target, key) // 删除属性 Reflect 是提供统一的操作对象 API，为 proxy 提供便利：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function reactive(target) { return new Proxy(target, { get(target, key, receiver) { // 使用 Reflect 可以确保 this 的正确指向 const res = Reflect.get(target, key, receiver) track(target, key) return res }, set(target, key, value, receiver) { // 返回布尔值判断操作是否成功 const res = Reflect.set(target, key, value, receiver) trigger(target, key) return res } }) } 新增响应式 API ref 和 reactive ref 和 reactive 都是 Vue3 新增的响应式 API，可以用来处理响应式数据，二者在使用上有些不同：\n特性 ref reactive 访问方式 .value 访问 直接访问 自动解包 在 \u003ctemplate\u003e 和 reactive 中自动解包 不需要解包 数据类型支持 支持所有数据类型 仅支持对象类型 解构行为 解构后失去响应式，需要用 toRef / toRefs 解构后失去响应式，需要用 toRef / toRefs 赋值特点 可以直接替换整个值 ref.value = newValue 不能直接替换整个对象，只能修改属性 嵌套数据 内部自动调用 reactive 处理对象 深层响应式转换 使用场景 基本数据类型 / 单一数据源 / 组合函数返回值 / 需要重新赋值的数据 有关联的数据集合 / 引用数据类型 / 不需要重新赋值的数据 访问方式 ref 对象通过 .value 访问，reactive 直接访问。\nconst count = ref(0) console.log(count.value) // 需要 .value 访问 const obj = reactive({ count: 0 }) console.log(obj.count) // 直接访问，无需 .value 自动解包 ref 对象在 template、reactive 中自动解包\n\u003ctemplate\u003e \u003cdiv\u003e \u003c!-- 已自动解包，直接访问，无需 .value ---\u003e {{ count }} \u003c/div\u003e \u003c/template\u003e \u003cscript setup\u003e const count = ref(0) // 在 reactive 对象中 ref 会自动解包 const state = reactive({ count, // 自动解包 double: computed(() =\u003e state.count*2), }) \u003c/script\u003e 数据类型支持 // ref 支持所有数据类型 const num = ref(0) const str = ref('XD') const boo = ref(true) const obj = ref({a:1, b:2}) const arr = ref([1,2]) // reactive 只支持引用数据类型(对象/数组) const obj2 = reactive({a:1, b:2}) const arr2 = reactive([1,2]) 使用 toRef / toRefs 解构 const obj = reactive({name: 'River', age: 18}) const { age } = obj // 直接解构会失去响应式 // 使用 toRef const age = toRef(obj, 'age') // 或者 toRefs const { name, age } = toRefs(obj) // 这样做的好处是可以使对象保持响应式 // 修改 ref 会更新源对象 age.value++ console.log(obj.age) // 19 // 修改源对象会更新 ref obj.age++ console.log(age.value) // 20 赋值特点 ref 对象可以直接替换，reactive 不可直接替换，只能修改属性\nconst foo = ref([1,2]) foo.value = [3,4] // 可以 const foo = reactive([1,2]) foo = [3,4] // 不行 嵌套数据 ref 处理嵌套数据\nconst user = ref({ name: 'Zhang', profile: { age: 25, address: { city: 'Beijing' } } }) // ref 内部会用 reactive 深层转换对象 user.value.profile.age = 26 // 触发响应式更新 user.value.profile.address.city = 'Shanghai' // 触发响应式更新 reactive 处理嵌套数据\nconst user = reactive({ name: 'Zhang', profile: { age: 25, address: { city: 'Beijing' } } }) // reactive 会深层转换所有嵌套对象 user.profile.age = 26 // 触发响应式更新 user.profile.address.city = 'Shanghai' // 触发响应式更新 使用场景 组合是函数的返回值使用 ref 更佳，如需 reactive，要通过 toRefs 来维持数据响应式\nfunction useCount() { const count = ref(0) return count } function useUser() { const state = reactive({name: 'River', age: 18}) return toRefs(state) } watchEffect watchEffect 自动跟踪响应式依赖，并在响应式依赖更新时重新运行副作用函数。简单来说，它会做这些事情：\n立即执行一次回调函数 自动跟踪回调函数内使用的响应式依赖 在依赖变化时，重新执行回调函数 基础用法 import { ref, watchEffect } from 'vue' const count = ref(0) const message = ref('Hello') watchEffect(() =\u003e { console.log(`Count: ${count.value}, Message: ${message.value}`) }) // 修改任何依赖都会触发回调 count.value++ // 输出：Count: 1, Message: Hello message.value = 'Hi' // 输出：Count: 1, Message: Hi 暂停/恢复/停止 监听 watchEffect 还会返回一个停止函数，执行它就会停止监听\nconst stop = watchEffect(() =\u003e {}) // 当不再需要监听时 stop() 当需要暂停/恢复的时候\nconst { stop, pause, resume } = watchEffect(() =\u003e {}) // 暂停 pause() // 恢复 resume() // 停止 stop() 清理副作用 为什么要清理副作用：\n防止内存泄漏（比如定时器） 避免事件重复监听 取消不需要的网络请求 清理可能产生冲突的旧状态 watchEffect 回调函数中的 onCleanup 这个入参就是用来清理副作用的，它的执行时机有：\nwatchEffect 即将重新执行时 watchEffect 被停止时 我们拿一个网络请求举例，创建了一个网络请求的控制器 controller，并且在 onCleanup 函数中调用了取消网络请求的方法。\nconst userId = ref('1') const userData = ref(null) watchEffect((onCleanup) =\u003e { // 创建一个取消控制器 const controller = new AbortController() // 网络请求 fetch(`/api/user/${userId.value}`, { signal: controller.signal, }).then(data =\u003e userData.value = JSON.parse(data)) // 清理函数：如果 userId 改变，则取消之前的请求 onCleanup(() =\u003e { controller.abort() }) }) setTimeout(() =\u003e { userId.value = '2' }, 100) 执行顺序是这样的：\nMarkdown初始执行： 1. 开始请求，userId: 1 100 ms后修改 userId： 2. 执行清理，取消之前的网络请求 (清理之前的副作用`onCleanup`) 3. 请求被取消 (之前的请求被 `abort`) 4. 开始请求，userId: 2 (重新执行 `watchEffect`) 3.5+ 后的副作用清理\nimport { onWatcherCleanup } from 'vue' // ... watchEffect(() =\u003e { // ... onWatcherCleanup(() =\u003e { controller.abort() }) // ... }) // ... 执行时机 watchEffect 还提供第二个参数，可以用来控制副作用函数的执行时机。\n1 2 3 4 5 6 7 8 9 10 11 12 // 默认：组件更新前执行, flush: 'pre' watchEffect(() =\u003e {}) // 组件更新后执行 watchEffect(() =\u003e { // ... }, flush: 'post') // 同步执行 watchEffect(() =\u003e { // ... }, flush: 'sync') watchEffect 和 watch watchEffect 自动追踪依赖，watch 需要明确指定监听的源 watchEffect(() =\u003e console.log(count.value)) // 自动追踪依赖 watch(count, newVal =\u003e console.log(count.value)) // 明确执行依赖 watchEffect 默认立即执行，watch 需要设置 immediate: true watchEffect(() =\u003e {}) // 默认立即执行 watch(source, () =\u003e {}, { immediate: true }) // 默认不会立即执行，需设置 immediate 为 true "},"title":"Vue 响应式源码分析"}}
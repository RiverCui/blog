{"/about/":{"data":{"":"我是 River，我是一个全栈工程师。我喜欢编程，喜欢认知输入与输出，喜欢挑战。你可以通过邮件联系我 rivertsuiwork@gmail.com。\n搭建博客是因为需要一个独立空间存放文章，阅读、写作是我想要一直坚持下去的事情。非典型 INTJ，有一只猫，在学游泳，阅片量即将迈入900大关。\n本网站使用 Hugo 构建，使用 papermod 主题, 使用 Vercel 部署，域名由 Cloudflare 托管。本博客源代码已上传至 GitHub。"},"title":"About"},"/blog/capture-https-request-with-mobile-device/":{"data":{"":"","#":"最近在为公司重构项目，因为原本是原生安卓和ios应用，所以为了快速了解业务逻辑和编写新代码，我决定一边用手机操作业务进行抓包，一边对照已有文档、代码进行重构。这篇文章介绍了我是如何用一台电脑和手机来实现抓包移动设备网络请求的。\n首先介绍一下使用的工具 —— Charles，这是一款网络抓包工具，它允许开发者查看、监控发送和接收的HTTP/HTTPS通信数据，主要面向开发者对 Web应用、移动 App 等进行网络调试和分析。你可以点击进入 Charles 官网下载，支持 Windows、macOS 和 Linux。\n基本使用 安装好 Charles 后，可以按照我下面给出的步骤进行使用：\n1. 让你的手机和电脑处在同一局域网 2. 电脑运行 Charles（默认端口号 8888） 3. 打开手机的 WLAN 设置 修改以下三项，可参考下方小米手机截图：\n代理：改为手动\n主机名：填写你的电脑 IP\n端口号： 8888（8888 为 Charles 默认端口号，如有需要可以在 Charles 中的 Proxy Settings 修改）\n4. 在手机中打开需要抓取的 App 现在你可以看到 Charles 已经开始正常运行，开始抓取 HTTP 请求了。\n虽然 HTTP 请求抓取正常，但你也许会和我一样，有需要抓取 HTTPS 请求的使用场景，但此时 Charles 抓包会出现乱码，这是由于 HTTPS 更高的安全性，我们要提供证书才可以正常获取数据。\n配置以抓包 HTTPS Request 在移动设备上安装证书：\n1. 配置 Charles 的 SSL Proxy -\u003e SSL Proxying Settings\n添加 *:443。\n2. 从 Charles 下载证书 打开 Charles，Help -\u003e SSL Proxying，因为我们使用的是手机，所以这里就选择 Mobile Device。\nCharles 会弹出提示，我们根据提示，用手机访问 chls.pro/ssl 下载证书。\n3. 手机安装证书 还是以小米手机为例，系统是 MUI 13.0.7，安装证书步骤如下：\n安全 -\u003e 更多安全设置 -\u003e 加密与凭据 -\u003e 安装证书 -\u003e CA 证书，然后选择刚才下载好的 Charles 证书安装\n现在再打开 Charles，可以看到抓到的 HTTPS 请求信息了。"},"title":"使用 Charles 抓取移动设备 HTTPS 请求"},"/blog/css-masonry/":{"data":{"":"","#":"围绕 Masonry 展开的辩论 前段时间，WebKit 团队发表了一篇名为 Help us invent CSS Grid Level 3, aka “Masonry” layout 的文章，讨论了关于 Masonry layout 的提案。\nMasonry 在英文中的意思是建筑物的砖石部分（如下图）。\nmasonry 布局是一种类似砖墙或石墙的模式的布局，也就是我们常说的瀑布流布局，这种布局样式很常见，比如 Pinterest 、小红书等都采用了这种样式。\nMasonry 是最开始也是由 WebKit 团队提出的，你可以在 MDN 上查看到它的使用方法（现在只有 Safari 和 Firefox 浏览器支持）。而在 WebKit 发表的这篇文章中，他们解释了为什么他们认为 Masonry 应该成为 CSS Grid 的一部分，并且解释了如果 CSS Working Group 使用替换方案 display: masonry 的可行性，并且向开发者、设计师寻求建议。\nChrome 团队也在前几日站出来，发表了一篇名为 An alternative proposal for CSS masonry 的文章，关于 CSS Masonry，他们明确的提出了 “implementing it as a part of the CSS Grid specification [..] would be a mistake\"（将其作为 CSS Grid 规范的一部分是个错误）的观点。\nMasonry 怎么用 虽然瀑布流很常见，但是作为一名前端工程师，我还从未写过这种样式，趁热打铁，就用这个新布局来写一个瀑布流页面。\n首先我们建一个 html 文件，添加一些图片做瀑布流使用。\n\u003cdiv class=\"gallery-container\"\u003e \u003cfigure\u003e \u003cimg src=\"https://picsum.photos/seed/1715619706392/500/500\"\u003e \u003c/figure\u003e \u003cfigure\u003e \u003cimg src=\"https://picsum.photos/seed/1715619668573/500/1000\"\u003e \u003c/figure\u003e \u003cfigure\u003e \u003cimg src=\"https://picsum.photos/seed/1715619707240/500/500\"\u003e \u003c/figure\u003e \u003cfigure\u003e \u003cimg src=\"https://picsum.photos/seed/1715619669966/500/1000\"\u003e \u003c/figure\u003e \u003cfigure\u003e \u003cimg src=\"https://picsum.photos/seed/1715619687217/500/800\"\u003e \u003c/figure\u003e \u003cfigure\u003e \u003cimg src=\"https://picsum.photos/seed/1715619713060/500/500\"\u003e \u003c/figure\u003e \u003c/div\u003e 然后写入 CSS，通过 grid-template-rows: masonry 来实现瀑布流布局。\nimg { width: 500px; object-fit: contain; border-radius: 15px; } .gallery-container { display: grid; grid-template-columns: repeat(3, 1fr); grid-gap: 1rem; grid-template-rows: masonry; } 我们可以看到，虽然 grid 布局生效了，但 grid-template-rows: masonry 并未生效，图与图之间存在大片的空白。\n这是因为 Masonry 目前只是个实验性功能，大部分浏览器还不支持，你可以下载 Safari Technology Preview 或者 Firefox Nightly 来体验这个新特性。\n我使用的是 safari tp，如下图所示，一个简单的瀑布流就实现了。\n得益于 masonry，整个实现过程非常简单。附上完整代码：waterfall-demo\n我的观点 首次使用这个新功能的时候，有些地方是很迷惑的。\n首先，作为一个 nonnative English speaker，masonry 这个词对我来说非常陌生，并不像 CSS 中常见的 border、center、none 让人一目了然，是有语言门槛的。\n其次，对于 grid-template-columns/grid-template-rows 搭配 masonry 使用，与我的思维习惯相悖，简单来说就是，要想实现纵向的瀑布流，需要使用 grid-template-rows: masonry，而我潜意识认为是 grid-template-columns。这里有点像一个习惯使用 windows 的人，第一次用 macos 浏览网页对于上下滚动的无所适从。\n总结一下，我对 Masonry 的建议有两点：\n将 masonry 这个单词换成更容易理解的 waterfall 和 chrome 团队的观点一样，Masonry 不应该是 Grid 的一部分，应该单独的使用 —— display: masonry。 "},"title":"CSS Masonry"},"/blog/docker-proxy-configuration/":{"data":{"":"Docker Desktop 登录失败有很多原因，如果使用网页打开 Docker Hub 登录没问题，但是 Docker Desktop 登录超时，大概率是因为代理问题，可以参考下面的方法进行配置。","登录问题#登录问题":"首先你要有一个代理（自行 Google），获取到代理的端口号。例如我使用的是 Clash，在设置中可以看到端口号为 7897。\n打开 Docker Desktop 设置，Resource -\u003e Proxies。\n打开 Manual Proxy configuration 状态，添加 Web Server(HTTP) 和 Web Server(HTTPS)，端口号为代理端口号。\n重启 Docker Desktop 就可以正常登录了。","镜像加速#镜像加速":"国内从 Docker Hub 拉去镜像有时会遇到困难，可以参考国内的 Docker Hub 镜像加速器配置镜像加速。"},"title":"Docker 代理配置（解决登录失败问题）"},"/blog/how-to-manage-files-on-cloud-storage-with-rclone/":{"data":{"":"在现代数据管理中，云存储已经成为不可或缺的一部分。无论是个人用户还是企业用户，云存储都提供了便捷的存储和访问方式。本文将介绍如何使用 Rclone 这个强大的命令行工具来管理阿里云 OSS(对象存储服务) 文件。","什么是-rclone#什么是 Rclone？":"Rclone 是一个开源命令行程序，支持多种云存储服务，包括 Google Drive、Amazon S3(阿里云OSS、腾讯COS、华为OBS等)、Dropbox。他可以用于同步文件、备份数据、迁移存储，以及其他文件管理任务。Rclone 提供了丰富的功能，如加密、压缩、多线程下载等，非常适合高效管理云存储文件。\n它支持以下功能：\n按需复制，每次仅仅复制更改的文件 断电续传 压缩传输 ","安装-rclone#安装 Rclone":"首先，我们需要安装 Rclone。可以从 Rclone 官网 下载适合你操作系统的安装包，并按照响应的安装步骤进行安装。\n对于 macOS 用户，可以通过 brew 进行安装：\nbrew install rclone 如果你是 Windows 用户，可以下载 .exe 文件并运行安装程序。","常用操作示例#常用操作示例":"列出存储桶(bucket)中的文件 rclone ls alioss:your-bucket-name 上传文件到bucket rclone copy /path/to/local/file alioss:your-bucket-name 下载文件到本地 rclone copy alioss:your-bucket-name /path/to/local/dir 同步本地目录和存储桶 rclone sync /path/to/local/dir alioss:your-bucket-name ","总结#总结":"Rclone 是一个功能强大的工具，能够帮助你高效地管理阿里云 OSS 或是其他云服务的文件，通过简单的配置和命令行操作，你可以轻松实现文件的上传\n、下载和同步等任务。希望本文能够帮助你快速上手 Rclone，并充分利用其强大的功能来管理你的云存储文件。","配置-rclone-连接阿里云-oss#配置 Rclone 连接阿里云 OSS":"安装完成后，我们需要配置 Rclone 以链接阿里云 OSS。打开终端(Terminal)，输入以下命令启动配置向导：\nrclone config 接下来，你会看到一个交互式的配置界面：\nNo remotes found - make a new one n) New remote s) Set configuration password q) Quit config n/s/q\u003e 输入 n 并按回车，开始创建一个新的 remote。然后按照提示输入以下信息：\nremote 名称：例如alioss 存储类型：输入 4，即 Amazon S3 Compliant Storage Providers 服务提供商：输入 2，即 Alibaba Cloud Object Storage System (OSS) formerly Aliyun Access Key ID 和 ACCESS Key Secret：从阿里云 OSS 控制台获取 Endpoint：选择你的 OSS 终端节点，例如 oss-cn-shenzhen.aliyuncs.com 其他选项：根据需要配置，通常可以使用默认值 配置完成后，保存并退出。"},"title":"如何使用 Rclone 高效管理云存储文件"},"/blog/https-for-local-development/":{"data":{"":"我最近在开发一个能够提供扫码功能的网页，但是扫码功能需要调用相机权限，浏览器出于安全考虑只在 HTTPS 环境下允许。所以想要在本地调试这些功能，需要为本地开发服务器配置 HTTPS。解决这个问题的本质就是生成本地证书和自签名，网上能找到很多方法，在这里我会介绍两种，看到这篇博客的朋友可以跟着下面的步骤实践，足够你在简单基础的开发中去使用。","mkcert#mkcert":"mkcert 是一个简化了的本地 CA 工具，用来生成有效的本地 HTTPS 证书。mkcert 的使用和证书配置步骤如下：\n1.安装 如果你也是 macOS 系统且安装了 homebrew，可以按照下面这个方式进行安装：\nbrew instal mkcert brew install nss # 如果电脑中有 Firefox，还需要这一步骤，否则会报错 如果你是 Windows，可以点击此处查看安装步骤。\n2.安装本地 CA mkcert -install 3.为 localhost 创建证书 mkcert localhost 127.0.0.1 ::1 创建成功后，Terminal 会显示证书的存放位置和过期时间，如下：\nThe certificate is at \"./localhost+2.pem\" and the key at \"./localhost+2-key.pem\" ✅ It will expire on 25 March 2026 🗓 4.将证书存放在项目中 在项目目录下新建一个文件夹，方便管理证书。\n例如我在我的项目目录下新建了一个 cert 的文件夹，并将刚才生成的 localhost+2.pem 和 localhost+2-key.pem 移动到该目录下。\n5.配置 vite 以使用 HTTPS 我的项目技术栈是 vue3 + vite，所以这里配置的是 vite.config.js 文件，如果你使用其他构建工具(比如vue-cli + webpack)，配置方法也都大同小异，只需查阅官方文档做出相应调整即可。 注意：修改配置后记得重新运行服务。\n// vite.config.js import fs from 'fs'; import path from 'path'; export default defineConfig({ // ... server: { // ... https: { key: fs.readFileSync(path.resolve(__dirname, 'cert/localhost+2-key.pem')), cert: fs.readFileSync(path.resolve(__dirname, 'cert/localhost+2.pem')), }, }, }) ","vue--react-自带选项#Vue / React 自带选项":"不管是 React 还是 Vue，都自带了开启 HTTPS 的选项，这也使得我们在本地使用 HTTPS 协议更加简单。\n也以 vite 为例，官方文档中有提到，如果需要合法证书，可以使用它们提供的插件 @vitejs/plugin-basic-ssl，这个插件会自动创建和缓存一个自签名的证书。\n1.安装插件 @vitejs/plugin-basic-ssl： pnpm add @vitejs/plugin-basic/ssl -D 2.配置 vite 配置 vite 后运行即可，需要注意浏览器可能会有安全警告，这是因为我们生成的自签名证书不是受信任的证书颁发机构签发的，但不妨碍我们开发使用，只要不投入生产环境使用就没问题。\n// vite.config.js export default defineConfig({ // ... plugins: [ // ... basicSsl(), ], server: { // ... https: true, }, }) "},"title":"使用 mkcert/Vite 生成本地证书"},"/blog/module-management/":{"data":{"":"","commonjs#\u003ccode\u003eCommonJS\u003c/code\u003e":"","es-modules#\u003ccode\u003eES Modules\u003c/code\u003e":"","esm-向下兼容#\u003ccode\u003eESM\u003c/code\u003e 向下兼容":"模块化及其优势 Node.js 与 浏览器的 JavaScript 最大不同就在于 Node.js 是模块化的。\n模块化 模块化是一种编程范式，将大型、复杂的程序系统分解成更小、更易管理和维护的部分。在模块化中，每个模块执行一项特定的功能，同时尽可能减少与其他模块的直接交互。这样的方法有很多优点：\n封装。每个模块将数据和功能封装在模块内部，并提供接口与外界交互。有助于隐藏内部实现细节，减少模块间的相互依赖。 重用性。模块化可以使开发者在项目多处重复使用代码块，也可以在多个项目或应用程序中使用，减少重复代码的编写，提高代码整体质量。 可维护性和可读性。模块化代码通常更易于理解和维护，每个模块负责清晰定义的功能，使得代码更加直观和易于管理。 独立性。模块之间的松耦合确保了修改一个模块不会或很少影响其他模块，有助于添加、更新和修复功能。 Node.js 的模块化选择 在 Node.js 诞生之初，JavaScript 还没有标准的模块机制，因此 Node.js 一开始采用了 CommonJS(下文简写为 CJS)。随后，JavaScript 标准的模块化机制 ES Modules(下文简写为 ESM) 诞生，浏览器开始逐步支持 ESM。在 Node.js 支持 ESM 之前，就有 Babel 这样的编译工具和 Webpack 这样的打包工具，将规范的 ESM 模块机制编译成 Node.js 的 CJS 模块机制了。随后，在Node.js v13.2.0 也开始引入了规范的 ESM 机制，同时兼容早期 CJS。\n所以我们现在写 Node.js 模块的时候，有 3 种思路：\n直接采用 ESM，在 Node.js v13.2.0 之后的版本可行。 使用 ESM，但是通过 Babel 编译成 CJS。 使用 CJS，Node.js 在未来很长一段时间还是会同时兼容 ESM 和 CJS 的。 ES Modules export 导出， import 导入\n导出语法 exporting declaration 导出声明\nexport let a, b export const a = 1, b = 2 export function functionName () {} export class ClassName {} export const { a, b } = obj export const [ a, b ] = arr 例如：\n// hello.mjs export const name = 'River' // index.mjs import { name } from './hello.mjs' export list 导出列表\nexport { name1, name2 } export { variable1 as name1, variable2 as name2 } export { variable1 as 'string name' } export { name1 as default } 例如：\n// hello.mjs const name = 'River' const sayHello = (text) =\u003e `Hello ${text}!` export { name, sayHello as default } // index.mjs import { name } from './hello.mjs' import sayHello from './hello.mjs' console.log(sayHello(name)) // Hello River! default exports 默认导出\nexport default expression export default function functionName() {} export default class ClassName {} 此外，还有 export ... from ...的聚合语法，在此不做赘述，要想了解可以看 MDN-JavaScript-export。\n导入语法 基于上述的 export 导出方式可以知道，export 导出的 API 分为 default 和 非 default。总结一下，针对这两种 API，import 也有两种不同的导入方式（可查看上述例子）：\nimport { API } from 模块路径 // 非 default API import defaultAPI from 模块路径 // default API 当然，和 export 一样，import 也可以使用 as 给 API 重命名。\nimport { variable1 as name1 } from 模块路径 import * as foo from 模块路径 上述的 import * as foo 可以将导出 API 生成对象 foo，并且 default API 为 foo.default。\n文件名后缀 需要注意的是，在 Node.js 中默认使用 CommonJS 规范定义 .js 文件的模块，用 ES Modules 规范定义 .mjs 文件的模块。关于这两者的启用规则，详细可查看 nodejs doc，在此不做赘述。\n如果要使用 ESM 定义 .js 文件的模块，可以在配置文件 package.json 中设置 type: module。\nCommonJS module.exports 导出，require 导入\n导出语法 module.exports module.exports = { name1, name2 } module.exports = { name1: variable1, name2: variable2 } // 不同于 ES Module 的 as 用法 exports exports.a = 1 exports.b = 2 exports.functionName = () =\u003e a + b 例如：\n// hello.js const name = 'River' const sayHello = (text) =\u003e `Hello ${text}!` module.exports = { name, sayHello } // index.js const { name, sayHello } = require('./hello.js') console.log(sayHello(name)) exports.属性名 是早期用法，现在应该尽量使用 module.exports = { 属性名 }。注意，两种语法不能同时使用，因为 exports.属性名 会被 module.exports = { 属性名 } 覆盖。\n导入语法 const { API } = require(模块路径) ESM 和 CJS 的差异 加载机制是理解这两个模块系统核心特性的关键，也是它们根本的区别所在。\nCJS 动态加载 运行时加载。模块依赖关系在代码执行时解析。这意味着 require() 函数调用是在代码执行过程中处理的，可以灵活使用模版字符串动态拼接路径，例如： const libPath = ENV.supportES6 ? './es6/' : './' const myLib = require(`${libPath}lib.js`) 还可以根据程序的运行逻辑和条件来加载模块。例如，可以在 if 中调用 require()，根据不同的条件加载不同的模块。 let api; if(condition) { api = require('./foo'); } else { api = require('./bar'); } 同步加载。在不需要考虑网络延迟的情况下，尤其是服务器端 JavaScript(Node.js)，模块一般都是从本地文件系统中加载，此时同步加载是可行的。 ESM 静态加载 编译时加载。模块依赖关系在编译时就确定。import 和 export 都必须放在最外层，不能被包含在函数或条件语句内。 异步加载。异步加载允许代码在模块下载和处理期间继续执行，解决了阻塞问题，当然也使模块管理更加复杂。 ESM 实现动态加载 ESM 不允许 import 语句用动态路径，也不允许在语句块中使用，但允许通过使用 import() 函数实现动态加载，而且是异步进行的。\n动态的 import() 返回一个 Promise，该 Promise 解析为引入模块的所有导出。需要使用 .then()、async/await 等方式来处理导入的模块。例如：\n(async function() { const { functionName } = await import('./myModules.mjs) functionName() }()) 使用场景：\n条件加载 例如： if(someCondition) { import('./myModules.mjs') .then(module =\u003e { module.functionName() }) } 性能优化。比如在处理大型模块时，通过代码分割和懒加载，减少应用的初始负载时间，提升性能。 ESM 向下兼容 在 Node.js 环境中，ES Modules 会向下兼容 CommonJS，对于 CJS 导出的 API，也可以使用 import() 引入，并且只能以 default 方式引入。例如：\n// foo.js const a = 1 const b = 2 const c = () =\u003e a + b module.exports = { a, b, c } // bar.mjs import abc from './foo.js' console.log(abc.a, abc.b, abc.c()) // 1, 2, 3 也就是说，module.exports 相当于：\nconst abc = { a, b, c } export default abc ","esm-和-cjs-的差异#\u003ccode\u003eESM\u003c/code\u003e 和 \u003ccode\u003eCJS\u003c/code\u003e 的差异":"","模块化及其优势#模块化及其优势":""},"title":"模块管理"},"/blog/mysql/":{"data":{"error-1819-hy000-your-password-does-not-satisfy-the-current-policy-requirements#ERROR 1819 (HY000): Your password does not satisfy the current policy requirements":"运行下方代码会报错\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'admin' 错误信息：ERROR 1819 (HY000): Your password does not satisfy the current policy requirements。密码不符合安全要求，改下密码的安全要求就可以了。解决步骤：\n登录 MySQL\nmysql -u root -p 检查当前密码策略\nSHOW VARIABLES LIKE 'validate_password%'; +-------------------------------------------------+--------+ | Variable_name | Value | +-------------------------------------------------+--------+ | validate_password.changed_characters_percentage | 0 | | validate_password.check_user_name | ON | | validate_password.dictionary_file | | | validate_password.length | 8 | | validate_password.mixed_case_count | 1 | | validate_password.number_count | 1 | | validate_password.policy | MEDIUM | | validate_password.special_char_count | 1 | +-------------------------------------------------+--------+ 修改当前密码策略\nSET GLOBAL validate_password.length=4; SET GLOBAL validate_password.policy=LOW; 现在密码策略已经修改了\n+-------------------------------------------------+-------+ | Variable_name | Value | +-------------------------------------------------+-------+ | validate_password.changed_characters_percentage | 0 | | validate_password.check_user_name | ON | | validate_password.dictionary_file | | | validate_password.length | 4 | | validate_password.mixed_case_count | 1 | | validate_password.number_count | 1 | | validate_password.policy | LOW | | validate_password.special_char_count | 1 | +-------------------------------------------------+-------+ 刷新权限并再次尝试修改密码\nFLUSH PRIVILEGES ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'admin'; ","mysql安装和使用#MySQL安装和使用":"MySQL安装和使用","命令行工具#命令行工具":"全部命令行请查看官方文档：mysql Client Commands\n下面列举几种常用的：\n\\g 和 \\G 都是命令的结束符，除此之外，也可以直接使用 ; 来结束命令。\n\\g # 将命令发送到 MySQL 服务器 \\G # 将命令发送到 MySQL 服务器，并且格式化输出 \\c # 清除当前输入 \\q # 退出 MySQL ","基础使用#基础使用":"连接 MySQL mysql -u root -p Enter password:****** 基本命令 查看数据库列表 SHOW DATABASES; 创建数据库 CREATE DATABASE testdb; 使用数据库 USE testdb; 创建表 CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(100), email VARCHAR(100) ); 查看表结构 DESCRIBE users; 数据操作 插入数据 INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com'); 查询数据 SELECT * FROM users; 更新数据 UPDATE users SET email = 'john.doe@example.com' WHERE name = 'John Doe'; 删除数据 DELETE FROM users WHERE name = 'John Doe'; 常用功能 条件查询 SELECT * FROM users WHERE email LIKE '%@example.com'; 排序查询 SELECT * FROM users ORDER BY name ASC; 聚合函数 SELECT COUNT(*) FROM users; SELECT AVG(id) FROM users; 多表操作 创建第二个表 CREATE TABLE orders ( order_id INT AUTO_INCREMENT PRIMARY KEY, user_id INT, product_name VARCHAR(100), FOREIGN KEY (user_id) REFERENCES users(id) ); 连接查询 SELECT users.name, orders.product_name FROM users JOIN orders ON users.id = orders.user_id; SELECT users.name, orders.product_name 子句指定我们希望从数据库中提取的列，这里会提取到两个列：\nusers 表中的 name 列(users.name) orders 表中的 product_name 列(orders.product.name) FROM users 子句指定我们查询的第一个表，即 users 表。 JOIN orders ON users.id = orders.user_id 子句用于将两个表连接起来。即使用内连接(INNER JOIN)将 users 表和 orders 表关联起来。连接条件是 users.id = orders.user_id。 内连接(INNER JOIN)会返回两个表中满足条件的所有记录。如果一条记录在 users 表和 orders 表中都有对应的匹配记录，那么这条记录会被包括在结果集中。简单来说，这个查询会返回所有有订单的用户及其订单的产品名称。\n举个例子，假如有以下两个表：\nusers 表：\nid name 1 Alice 2 Bob 3 Charlie orders 表：\norder_id user_id product_name 101 1 Laptop 102 1 SmartPhone 103 2 Tablet 执行上述 SQL 语句后，查询结果是：\nname product_name Alice Laptop Alice Smartphone Bob Tablet ","安装#安装":"MySQL Community Server MySQL Community Server 是数据库服务器，它负责实际存储和管理数据。\n下载地址：https://dev.mysql.com/downloads/mysql/\n选择版本和操作系统，点击 Download 按钮下载。我是 macOS 14 系统，M1 芯片，这里就选择了 macOS 14 (ARM, 64-bit), DMG Archive 下载。\n安装完成后，打开系统设置，拉到最下方就能看到 MySQL，点击按钮运行 MySQL 服务。\nMySQL Workbench MySQL Workbench 是一个客户端应用程序，你可以用它来连接到 MySQL Community Server，进行数据库设计、开发和管理等操作。\n要注意版本保持一致，下载地址：https://dev.mysql.com/downloads/workbench/\n安装后打开，点击 Connection 或者新建一个，输入密码就OK了。","常见问题#常见问题":"","环境变量#环境变量":"查看当前 shell\necho $SHELL 如果是 /bin/bash，说明用的是 bash，如果是 /bin/zsh，说明用的是 zsh。\n如果是 bash:\n# 1. 更改 vim ~/.bash_profile # 2. 添加 export PATH=${PATH}:/usr/local/mysql/bin # 3. 更新 source ~/.bash_profile 如果是 zsh：\n# 1. 更改 vim ~/.zshrc # 2. 添加 export PATH=${PATH}:/usr/local/mysql/bin # 3. 更新 source ~/.zshrc ","用-mysql-workbench-新建-table-时没有-apply-按钮#用 mysql workbench 新建 table 时没有 apply 按钮":"8.0.36 版本有问题，替换成 8.0.34 就正常使用了。","进入-mysql-cli#进入 MySQL CLI":" mysql -u root -p 输入安装时密码，即可成功进入 MySQL CLI。"},"title":"MySQL 安装和基础使用"},"/blog/npm/":{"data":{"":"","npm#NPM":"NPM NPM 是 Node.js 自带的包管理工具。\nNode.js 的模块大致分为内部模块和其他模块。内部模块是 Node.js 内部集成的模块，不需要引用 JS 外部文件，而是通过 require 或 import 模块名引入。\n比如内置 fs 模块（文件操作相关的模块），可以这样引入：\nconst fs = require('fs') 除了上图这些内置模块外，在开发中还会使用很多其他模块，有两种方式可以引入：\n通过文件路径引入\n例如，在下面这个项目中，想要在 b 目录下的 bar.js 中引入 a 目录下的 foo.js。\n- a foo.js - b bar.js 可以在 bar.js 里这样引入：\nconst foo = require('../a/foo.js') 通过 NPM 将模块安装到项目中(默认是 node_modules 目录)，在代码中用包名来引用模块。\nnpm registry 是 NPM 的官方仓库，可查找需要的包，并按照包文档的指引进行安装使用。\n比如，dayjs 这个插件，使用 NPM 安装：\nnpm install dayjs 使用：\nconst dayjs = require('dayjs') dayjs().format() 当通过包名引入模块时，Node.js 会根据 resolve 算法先搜索模块所在的目录下的 node_modules，如果没找到，会递归查找上级目录中的 node_modules，直到根目录。\nNPM 值得讲的很多，以后会单独开个专题✍️。"},"title":"NPM"},"/blog/personal-rss-feed-recommendations/":{"data":{"":"","#":"作为一个多年使用 RSS 阅读的人来说，RSS 是我每天了解最新的科技、技术、时事的主要渠道之一。\n这篇文章会推荐一些我认为不错的订阅，不管你刚上手 RSS 或者想丰富自己的订阅库，都可以参考一下我的 List。\n科技 中文 极客公园\n阮一峰的网络日志\n1Link.Fun\nSuperTechFans：每天用 AI 总结 Hacker News 的 Top 10 文章\n英文 tldr.tech：Too long don’t read，每日发送几则科技文章摘要\nthe DONUT：不止科技消息，涵盖很多\n技术 中文 山月前端周刊\n掘金前端本周最热\n美团技术团队\n值得一读技术博客\n前端食堂\n英文 Frontend Focus\nWeb.dev\nChangelog News\nJavaScript Weekly\nNode Weekly\n推荐的不多，也希望大家不要一次性订阅太多。因为我经历过一股脑订阅大量 newsletter，一天接收几百个推送，最后结果是压根不会打开去阅读，从订阅到放弃。希望大家在精不在多，这也避免了长期沉浸在 RSS 阅读而导致的信息茧房。\n除此之外，我最近在使用的阅读工具是 Readwise Reader，使用体验及其舒适，强烈推荐，后续我也会写专门一篇文章来介绍下这个优秀的 Web 应用。"},"title":"个人向的 RSS 订阅推荐"},"/blog/pre-knowledge-of-nodejs/":{"data":{"":"","nodejs-是-javascript-运行时环境#Node.js 是 JavaScript 运行时环境":"Node.js 是 JavaScript 运行时环境 Node.js® is an open-source, cross-platform JavaScript runtime environment.引用来源：Node.js\nNode.js 并不是一种语言而是一个平台，是 JavaScript 的运行时环境(runtime environment)/宿主环境(host environment)。\n讨论 Node.js 就不得不提到 Chrome V8 引擎。09年，谷歌开始研发 Chrome 浏览器，这也是现今使用最为广泛的浏览器，由 Lars Bak 领导开发的 Chrome V8 引擎也相应问世，JavaScript 就此展开了一场性能革命，Node.js 就是基于 Chrome V8 引擎构建的。随后，Node.js 的作者 Ryan Dahl 还构建了 Deno。\n如今，JavaScript 的层级架构也基本趋于稳定，如图：\n图片来源：掘金小册\n最下面的层级是脚本语言规范(Spec)，ECMAScript。 再往上一层是语言实现，JavaScript、JScript、ActionScript 等都是对 ECMAScript 的语言实现。 到了引擎层面，除了上文提到的 Chrome V8 外，还有 SpiderMonkey、QuickJS、JerryScript 等常见引擎。 最上面是运行时环境，基于 Chrome V8 封装的运行时环境有 Node.js、Chromium、Deno、CloudFlare Workers，Firefox 是基于 SpiderMonkey 封装的运行时环境。 ","使用场景#使用场景":" 服务端\nNode.js 提供了基于事件驱动和非阻塞的接口，可用于编写高并发状态下的程序，而且 JavaScript 的匿名函数、闭包、回调函数等特性就是为事件驱动而设计的。\nNode.js 一些内置模块如 http、net、fs，就是为服务端设计的。无论是 HTTP，还是 TCP、UDP，又或是 RPC 服务，Node.js 都可以胜任。\n桌面端\nElectron.js，由OpenJS基金会开发和维护的自由开源软件框架。该框架旨在使用Chromium浏览器引擎版本和使用Node.js运行时环境的后端渲染的网络技术创建桌面应用程序。\nVisual Studio Code、1Password、钉钉等软件，都是基于 Electron 开发的。\n端游\n除了通过 WebGL 在浏览器里写前端页面上的游戏、通过 Electron 封装成看起来像端游的游戏外，JavaScript 还能通过 Node.js 的 binding 去使用 OpenGL 甚至 DirectX 去写货真价实的桌面游戏。\n机器学习\npipcook\nNode.js 最早被设想为一种用于构建服务端应用的技术，但作为运行在操作系统中的 JavaScript 运行时环境，它已经成为了一个平台，可适配领域涵盖了泛前端和后端，传统服务和 Serverless，工具、商业、游戏等等。","基本架构#基本架构":" 图片来源：medium.com\nNode.js 是运行在操作系统之上的，底层由 Chrome V8 引擎和一些 C/C++ 写的库构成，比如 libUv、c-ares、llhttp/http-parser、open-ssl、zlib等。其中，libUV 负责处理事件循环，c-ares、llhttp/http-parser、open-ssl、zlib 等库提供 DNS 解析、HTTP 协议、HTTPS 和文件压缩等功能。\n中间层由 Node.js Bindings、Node.js Standard Library 和 C/C++ AddOns 构成。Node.js Bindings 层的作用是将底层那些用 C/C++ 写的库接口暴露给 JS 环境，而 Node.js Standard Library 是 Node.js 本身的核心模块。至于 C/C++ AddOns，它可以让用户自己的 C/C++ 模块通过桥接的方式提供给Node.js。\n再上一层是 Node.js 的 API 层，我们使用 Node.js 开发应用，主要使用的就是 API 层，Node.js 应用最终运行在 API 层之上。"},"title":"Node.js 前置知识"}}
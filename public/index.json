[{"content":"","date":"2023-11-06","permalink":"/tags/node.js/","section":"Tags","summary":"","title":"Node.js"},{"content":"","date":"2023-11-06","permalink":"/series/node.js/","section":"Series","summary":"","title":"Node.js"},{"content":" Node.js 是 JavaScript 运行时环境 # Node.js® is an open-source, cross-platform JavaScript runtime environment.引用来源： Node.js\nNode.js 并不是一种语言而是一个平台，是 JavaScript 的运行时环境(runtime environment)/宿主环境(host environment)。\n讨论 Node.js 就不得不提到 Chrome V8 引擎。09年，谷歌开始研发 Chrome 浏览器，这也是现今使用最为广泛的浏览器，由 Lars Bak 领导开发的 Chrome V8 引擎也相应问世，JavaScript 就此展开了一场性能革命，Node.js 就是基于 Chrome V8 引擎构建的。随后，Node.js 的作者 Ryan Dahl 还构建了 Deno。\n如今，JavaScript 的层级架构也基本趋于稳定，如图：\n图片来源： 掘金小册\n最下面的层级是脚本语言规范(Spec)， ECMAScript。 再往上一层是语言实现，JavaScript、JScript、ActionScript 等都是对 ECMAScript 的语言实现。 到了引擎层面，除了上文提到的 Chrome V8 外，还有 SpiderMonkey、QuickJS、JerryScript 等常见引擎。 最上面是运行时环境，基于 Chrome V8 封装的运行时环境有 Node.js、Chromium、Deno、CloudFlare Workers，Firefox 是基于 SpiderMonkey 封装的运行时环境。 基本架构 # 图片来源： medium.com\nNode.js 是运行在操作系统之上的，底层由 Chrome V8 引擎和一些 C/C++ 写的库构成，比如 libUv、c-ares、llhttp/http-parser、open-ssl、zlib等。其中，libUV 负责处理事件循环，c-ares、llhttp/http-parser、open-ssl、zlib 等库提供 DNS 解析、HTTP 协议、HTTPS 和文件压缩等功能。\n中间层由 Node.js Bindings、Node.js Standard Library 和 C/C++ AddOns 构成。Node.js Bindings 层的作用是将底层那些用 C/C++ 写的库接口暴露给 JS 环境，而 Node.js Standard Library 是 Node.js 本身的核心模块。至于 C/C++ AddOns，它可以让用户自己的 C/C++ 模块通过桥接的方式提供给Node.js。\n再上一层是 Node.js 的 API 层，我们使用 Node.js 开发应用，主要使用的就是 API 层，Node.js 应用最终运行在 API 层之上。\n使用场景 # 服务端\nNode.js 提供了基于事件驱动和非阻塞的接口，可用于编写高并发状态下的程序，而且 JavaScript 的匿名函数、闭包、回调函数等特性就是为事件驱动而设计的。\nNode.js 一些内置模块如 http、net、fs，就是为服务端设计的。无论是 HTTP，还是 TCP、UDP，又或是 RPC 服务，Node.js 都可以胜任。\n桌面端\nElectron.js，由OpenJS基金会开发和维护的自由开源软件框架。该框架旨在使用Chromium浏览器引擎版本和使用Node.js运行时环境的后端渲染的网络技术创建桌面应用程序。\nVisual Studio Code、1Password、钉钉等软件，都是基于 Electron 开发的。\n端游\n除了通过 WebGL 在浏览器里写前端页面上的游戏、通过 Electron 封装成看起来像端游的游戏外，JavaScript 还能通过 Node.js 的 binding 去使用 OpenGL 甚至 DirectX 去写货真价实的桌面游戏。\n机器学习\npipcook\nNode.js 最早被设想为一种用于构建服务端应用的技术，但作为运行在操作系统中的 JavaScript 运行时环境，它已经成为了一个平台，可适配领域涵盖了泛前端和后端，传统服务和 Serverless，工具、商业、游戏等等。\n","date":"2023-11-06","permalink":"/posts/node.js-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/","section":"Posts","summary":"Node.js 并不是一种语言而是一个平台，是 JavaScript 的\u003cstrong\u003e运行时环境\u003c/strong\u003e。","title":"Node.js 前置知识"},{"content":" NPM # NPM 是 Node.js 自带的包管理工具。\nNode.js 的模块大致分为内部模块和其他模块。内部模块是 Node.js 内部集成的模块，不需要引用 JS 外部文件，而是通过 require 或 import 模块名引入。\n比如内置 fs 模块（文件操作相关的模块），可以这样引入：\nconst fs = require(\u0026#39;fs\u0026#39;) 除了上图这些内置模块外，在开发中还会使用很多其他模块，有两种方式可以引入：\n通过文件路径引入\n例如，在下面这个项目中，想要在 b 目录下的 bar.js 中引入 a 目录下的 foo.js。\n- a foo.js - b bar.js 可以在 bar.js 里这样引入：\nconst foo = require(\u0026#39;../a/foo.js\u0026#39;) 通过 NPM 将模块安装到项目中(默认是 node_modules 目录)，在代码中用包名来引用模块。\nnpm registry 是 NPM 的官方仓库，可查找需要的包，并按照包文档的指引进行安装使用。\n比如， dayjs 这个插件，使用 NPM 安装：\nnpm install dayjs 使用：\nconst dayjs = require(\u0026#39;dayjs\u0026#39;) dayjs().format() 当通过包名引入模块时，Node.js 会根据 resolve 算法先搜索模块所在的目录下的 node_modules，如果没找到，会递归查找上级目录中的 node_modules，直到根目录。\nNPM 值得讲的很多，以后会单独开个专题✍️。\n","date":"2023-11-06","permalink":"/posts/npm/","section":"Posts","summary":"npm 是 JavaScript 的包管理工具。","title":"NPM"},{"content":"","date":"2023-11-06","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"2023-11-06","permalink":"/","section":"River's Blog","summary":"","title":"River's Blog"},{"content":"","date":"2023-11-06","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"2023-11-06","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":" 模块化及其优势 # Node.js 与 浏览器的 JavaScript 最大不同就在于 Node.js 是模块化的。\n模块化 # 模块化是一种编程范式，将大型、复杂的程序系统分解成更小、更易管理和维护的部分。在模块化中，每个模块执行一项特定的功能，同时尽可能减少与其他模块的直接交互。这样的方法有很多优点：\n封装。每个模块将数据和功能封装在模块内部，并提供接口与外界交互。有助于隐藏内部实现细节，减少模块间的相互依赖。 重用性。模块化可以使开发者在项目多处重复使用代码块，也可以在多个项目或应用程序中使用，减少重复代码的编写，提高代码整体质量。 可维护性和可读性。模块化代码通常更易于理解和维护，每个模块负责清晰定义的功能，使得代码更加直观和易于管理。 独立性。模块之间的松耦合确保了修改一个模块不会或很少影响其他模块，有助于添加、更新和修复功能。 Node.js 的模块化选择 # 在 Node.js 诞生之初，JavaScript 还没有标准的模块机制，因此 Node.js 一开始采用了 CommonJS(下文简写为 CJS)。随后，JavaScript 标准的模块化机制 ES Modules(下文简写为 ESM) 诞生，浏览器开始逐步支持 ESM。在 Node.js 支持 ESM 之前，就有 Babel 这样的编译工具和 Webpack 这样的打包工具，将规范的 ESM 模块机制编译成 Node.js 的 CJS 模块机制了。随后，在Node.js v13.2.0 也开始引入了规范的 ESM 机制，同时兼容早期 CJS。\n所以我们现在写 Node.js 模块的时候，有 3 种思路：\n直接采用 ESM，在 Node.js v13.2.0 之后的版本可行。 使用 ESM，但是通过 Babel 编译成 CJS。 使用 CJS，Node.js 在未来很长一段时间还是会同时兼容 ESM 和 CJS 的。 ES Modules # export 导出， import 导入\n导出语法 # exporting declaration 导出声明\nexport let a, b export const a = 1, b = 2 export function functionName () {} export class ClassName {} export const { a, b } = obj export const [ a, b ] = arr 例如：\n// hello.mjs export const name = \u0026#39;River\u0026#39; // index.mjs import { name } from \u0026#39;./hello.mjs\u0026#39; export list 导出列表\nexport { name1, name2 } export { variable1 as name1, variable2 as name2 } export { variable1 as \u0026#39;string name\u0026#39; } export { name1 as default } 例如：\n// hello.mjs const name = \u0026#39;River\u0026#39; const sayHello = (text) =\u0026gt; `Hello ${text}!` export { name, sayHello as default } // index.mjs import { name } from \u0026#39;./hello.mjs\u0026#39; import sayHello from \u0026#39;./hello.mjs\u0026#39; console.log(sayHello(name)) // Hello River! default exports 默认导出\nexport default expression export default function functionName() {} export default class ClassName {} 此外，还有 export ... from ...的聚合语法，在此不做赘述，要想了解可以看 MDN-JavaScript-export。\n导入语法 # 基于上述的 export 导出方式可以知道，export 导出的 API 分为 default 和 非 default。总结一下，针对这两种 API，import 也有两种不同的导入方式（可查看上述例子）：\nimport { API } from 模块路径 // 非 default API import defaultAPI from 模块路径 // default API 当然，和 export 一样，import 也可以使用 as 给 API 重命名。\nimport { variable1 as name1 } from 模块路径 import * as foo from 模块路径 上述的 import * as foo 可以将导出 API 生成对象 foo，并且 default API 为 foo.default。\n文件名后缀 # 需要注意的是，在 Node.js 中默认使用 CommonJS 规范定义 .js 文件的模块，用 ES Modules 规范定义 .mjs 文件的模块。关于这两者的启用规则，详细可查看 nodejs doc，在此不做赘述。\n如果要使用 ESM 定义 .js 文件的模块，可以在配置文件 package.json 中设置 type: module。\nCommonJS # module.exports 导出，require 导入\n导出语法 # module.exports module.exports = { name1, name2 } module.exports = { name1: variable1, name2: variable2 } // 不同于 ES Module 的 as 用法 exports exports.a = 1 exports.b = 2 exports.functionName = () =\u0026gt; a + b 例如：\n// hello.js const name = \u0026#39;River\u0026#39; const sayHello = (text) =\u0026gt; `Hello ${text}!` module.exports = { name, sayHello } // index.js const { name, sayHello } = require(\u0026#39;./hello.js\u0026#39;) console.log(sayHello(name)) exports.属性名 是早期用法，现在应该尽量使用 module.exports = { 属性名 }。注意，两种语法不能同时使用，因为 exports.属性名 会被 module.exports = { 属性名 } 覆盖。\n导入语法 # const { API } = require(模块路径) ESM 和 CJS 的差异 # 加载机制是理解这两个模块系统核心特性的关键，也是它们根本的区别所在。\nCJS 动态加载 # 运行时加载。模块依赖关系在代码执行时解析。这意味着 require() 函数调用是在代码执行过程中处理的，可以灵活使用模版字符串动态拼接路径，例如： const libPath = ENV.supportES6 ? \u0026#39;./es6/\u0026#39; : \u0026#39;./\u0026#39; const myLib = require(`${libPath}lib.js`) 还可以根据程序的运行逻辑和条件来加载模块。例如，可以在 if 中调用 require()，根据不同的条件加载不同的模块。 let api; if(condition) { api = require(\u0026#39;./foo\u0026#39;); } else { api = require(\u0026#39;./bar\u0026#39;); } 同步加载。在不需要考虑网络延迟的情况下，尤其是服务器端 JavaScript(Node.js)，模块一般都是从本地文件系统中加载，此时同步加载是可行的。 ESM 静态加载 # 编译时加载。模块依赖关系在编译时就确定。import 和 export 都必须放在最外层，不能被包含在函数或条件语句内。 异步加载。异步加载允许代码在模块下载和处理期间继续执行，解决了阻塞问题，当然也使模块管理更加复杂。 ESM 实现动态加载 # ESM 不允许 import 语句用动态路径，也不允许在语句块中使用，但允许通过使用 import() 函数实现动态加载，而且是异步进行的。\n动态的 import() 返回一个 Promise，该 Promise 解析为引入模块的所有导出。需要使用 .then()、async/await 等方式来处理导入的模块。例如：\n(async function() { const { functionName } = await import(\u0026#39;./myModules.mjs) functionName() }()) 使用场景：\n条件加载 例如： if(someCondition) { import(\u0026#39;./myModules.mjs\u0026#39;) .then(module =\u0026gt; { module.functionName() }) } 性能优化。比如在处理大型模块时，通过代码分割和懒加载，减少应用的初始负载时间，提升性能。 ESM 向下兼容 # 在 Node.js 环境中，ES Modules 会向下兼容 CommonJS，对于 CJS 导出的 API，也可以使用 import() 引入，并且只能以 default 方式引入。例如：\n// foo.js const a = 1 const b = 2 const c = () =\u0026gt; a + b module.exports = { a, b, c } // bar.mjs import abc from \u0026#39;./foo.js\u0026#39; console.log(abc.a, abc.b, abc.c()) // 1, 2, 3 也就是说，module.exports 相当于：\nconst abc = { a, b, c } export default abc ","date":"2023-11-06","permalink":"/posts/%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86/","section":"Posts","summary":"\u003ccode\u003eCommonJS\u003c/code\u003e 和 \u003ccode\u003eES Modules\u003c/code\u003e 是 JavaScript 中两种主要的模块系统。","title":"模块管理"},{"content":"","date":"0001-01-01","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"0001-01-01","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]
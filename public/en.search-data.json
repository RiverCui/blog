{"/en/capture-https-request-with-mobile-device/":{"data":{"":"","#":" Note: This article was translated from Chinese to English by Claude AI (Anthropic).\nRecently, while working on a project reconstruction for my company, which originally had native Android and iOS applications, I decided to understand the business logic and write new code by capturing network packets while operating the business on a mobile phone, referencing existing documentation and code for reconstruction. This article explains how I used a computer and a mobile phone to capture network requests from mobile devices.\nFirst, let me introduce the tool ‚Äî Charles, a network packet capture tool that allows developers to view and monitor HTTP/HTTPS communication data, primarily designed for developers to debug and analyze web applications and mobile apps. You can visit the Charles website to download it, which supports Windows, macOS, and Linux.\nBasic Usage After installing Charles, you can follow these steps:\n1. Ensure your phone and computer are on the same local network 2. Run Charles on your computer (default port 8888) 3. Open WLAN settings on your phone Modify the following three items, referring to the Xiaomi phone screenshot below:\nProxy: Change to Manual\nHostname: Enter your computer‚Äôs IP\nPort: 8888 (8888 is Charles‚Äô default port, which can be modified in Charles‚Äô Proxy Settings if needed)\n4. Open the app you want to capture on your phone Now you can see Charles running normally and starting to capture HTTP requests.\nAlthough HTTP request capture works fine, you might, like me, need to capture HTTPS requests. At this point, Charles will show scrambled data due to HTTPS‚Äôs higher security. We need to provide a certificate to properly access the data.\nConfiguring to Capture HTTPS Requests Installing certificates on mobile devices:\n1. Configure Charles SSL Proxy -\u003e SSL Proxying Settings\nAdd *:443.\n2. Download Certificate from Charles Open Charles, Help -\u003e SSL Proxying, and since we‚Äôre using a phone, select Mobile Device here.\nCharles will show a prompt. Following the instructions, use your phone to visit chls.pro/ssl to download the certificate.\n3. Install Certificate on Phone Taking a Xiaomi phone as an example, running MIUI 13.0.7, here are the steps to install the certificate:\nSecurity -\u003e More Security Settings -\u003e Encryption \u0026 Credentials -\u003e Install Certificate -\u003e CA Certificate, then select and install the Charles certificate you just downloaded\nNow when you open Charles, you can see the captured HTTPS request information."},"title":"Capturing Mobile Device HTTPS Requests with Charles"},"/en/css-masonry/":{"data":{"":"","#":" Note: This article was translated from Chinese to English by Claude AI (Anthropic).\nThe Debate Around Masonry Recently, the WebKit team published an article titled Help us invent CSS Grid Level 3, aka ‚ÄúMasonry‚Äù layout, discussing the proposal for Masonry layout.\nMasonry refers to the stonework of buildings (as shown below).\nMasonry layout is a pattern similar to brick or stone walls, commonly known as waterfall layout. This layout style is very common, used by sites like Pinterest and Xiaohongshu.\nMasonry was initially proposed by the WebKit team, and you can find its usage on MDN (currently only supported by Safari and Firefox browsers). In WebKit‚Äôs article, they explained why they believe Masonry should be part of CSS Grid, discussed the feasibility of using an alternative display: masonry approach if adopted by the CSS Working Group, and sought advice from developers and designers.\nThe Chrome team recently responded with an article titled An alternative proposal for CSS masonry, explicitly stating that ‚Äúimplementing it as a part of the CSS Grid specification [..] would be a mistake‚Äù.\nHow to Use Masonry Although waterfall layouts are common, I‚Äôve never written one as a frontend engineer. Let‚Äôs take this opportunity to create a waterfall page using this new layout.\nFirst, let‚Äôs create an HTML file and add some images for the waterfall layout.\n\u003cdiv class=\"gallery-container\"\u003e \u003cfigure\u003e \u003cimg src=\"https://picsum.photos/seed/1715619706392/500/500\"\u003e \u003c/figure\u003e \u003cfigure\u003e \u003cimg src=\"https://picsum.photos/seed/1715619668573/500/1000\"\u003e \u003c/figure\u003e \u003cfigure\u003e \u003cimg src=\"https://picsum.photos/seed/1715619707240/500/500\"\u003e \u003c/figure\u003e \u003cfigure\u003e \u003cimg src=\"https://picsum.photos/seed/1715619669966/500/1000\"\u003e \u003c/figure\u003e \u003cfigure\u003e \u003cimg src=\"https://picsum.photos/seed/1715619687217/500/800\"\u003e \u003c/figure\u003e \u003cfigure\u003e \u003cimg src=\"https://picsum.photos/seed/1715619713060/500/500\"\u003e \u003c/figure\u003e \u003c/div\u003e Then add CSS, using grid-template-rows: masonry to create the waterfall layout.\nimg { width: 500px; object-fit: contain; border-radius: 15px; } .gallery-container { display: grid; grid-template-columns: repeat(3, 1fr); grid-gap: 1rem; grid-template-rows: masonry; } We can see that while the grid layout works, grid-template-rows: masonry doesn‚Äôt take effect, leaving large gaps between images.\nThis is because Masonry is currently an experimental feature, unsupported by most browsers. You can download Safari Technology Preview or Firefox Nightly to try this new feature.\nI‚Äôm using Safari TP, and as shown below, a simple waterfall layout is achieved.\nThanks to masonry, the entire implementation is very simple. Here‚Äôs the complete code: waterfall-demo\nMy Opinion When first using this new feature, some aspects were confusing.\nFirst, as a non-native English speaker, the word ‚Äúmasonry‚Äù is very unfamiliar, unlike common CSS terms like border, center, none which are self-explanatory. There‚Äôs a language barrier.\nSecond, using grid-template-columns/grid-template-rows with masonry goes against my intuition. Simply put, to achieve a vertical waterfall flow, you need to use grid-template-rows: masonry, while I instinctively thought it would be grid-template-columns. It‚Äôs similar to how a Windows user might initially struggle with scrolling on macOS.\nTo summarize, I have two suggestions for Masonry:\nReplace the word ‚Äúmasonry‚Äù with the more intuitive ‚Äúwaterfall‚Äù Like the Chrome team‚Äôs view, Masonry shouldn‚Äôt be part of Grid, but should be used independently as display: masonry. "},"title":"CSS Masonry"},"/en/docker-proxy-configuration/":{"data":{"":" Note: This article was translated from Chinese to English by Claude AI (Anthropic).\nDocker Desktop login failures can occur for many reasons. If you can log in to Docker Hub via web browser without issues but Docker Desktop login times out, it‚Äôs likely due to proxy settings. You can follow the method below to configure it.","image-acceleration#Image Acceleration":"When pulling images from Docker Hub in China, you might encounter difficulties. You can refer to China‚Äôs Docker Hub Mirror Accelerators to configure image acceleration.","login-issues#Login Issues":"First, you need to have a proxy (Google it yourself) and get its port number. For example, I use Clash, and in its settings, I can see the port number is 7897.\nOpen Docker Desktop settings, go to Resource -\u003e Proxies.\nEnable Manual Proxy configuration, add Web Server(HTTP) and Web Server(HTTPS), using your proxy port number.\nRestart Docker Desktop and you should be able to log in normally."},"title":"Docker Proxy Configuration (Resolving Login Issues)"},"/en/how-to-manage-files-on-cloud-storage-with-rclone/":{"data":{"":" Note: This article was translated from Chinese to English by Claude AI (Anthropic).\nIn modern data management, cloud storage has become indispensable. Whether for individual users or enterprises, cloud storage provides convenient storage and access methods. This article will introduce how to use Rclone, a powerful command-line tool, to manage Alibaba Cloud OSS (Object Storage Service) files.","common-operations-examples#Common Operations Examples":"List files in bucket rclone ls alioss:your-bucket-name Upload files to bucket rclone copy /path/to/local/file alioss:your-bucket-name Download files to local rclone copy alioss:your-bucket-name /path/to/local/dir Sync local directory with bucket rclone sync /path/to/local/dir alioss:your-bucket-name ","configuring-rclone-to-connect-to-alibaba-cloud-oss#Configuring Rclone to Connect to Alibaba Cloud OSS":"After installation, we need to configure Rclone to connect to Alibaba Cloud OSS. Open Terminal and enter the following command to start the configuration wizard:\nrclone config You‚Äôll see an interactive configuration interface:\nNo remotes found - make a new one n) New remote s) Set configuration password q) Quit config n/s/q\u003e Enter n and press Enter to create a new remote. Then follow the prompts to enter the following information:\nRemote name: e.g., alioss Storage type: enter 4 for Amazon S3 Compliant Storage Providers Service provider: enter 2 for Alibaba Cloud Object Storage System (OSS) formerly Aliyun Access Key ID and ACCESS Key Secret: obtain from Alibaba Cloud OSS console Endpoint: choose your OSS endpoint, e.g., oss-cn-shenzhen.aliyuncs.com Other options: configure as needed, usually default values are fine After configuration, save and exit.","installing-rclone#Installing Rclone":"First, we need to install Rclone. You can download the appropriate installation package for your operating system from the Rclone website and follow the installation steps.\nFor macOS users, you can install via brew:\nbrew install rclone For Windows users, you can download the .exe file and run the installer.","summary#Summary":"Rclone is a powerful tool that can help you efficiently manage files in Alibaba Cloud OSS or other cloud services. Through simple configuration and command-line operations, you can easily accomplish tasks like file upload, download, and synchronization. I hope this article helps you get started with Rclone and fully utilize its powerful features to manage your cloud storage files.","what-is-rclone#What is Rclone?":"Rclone is an open-source command-line program that supports various cloud storage services, including Google Drive, Amazon S3 (Alibaba Cloud OSS, Tencent COS, Huawei OBS, etc.), and Dropbox. It can be used for file synchronization, data backup, storage migration, and other file management tasks. Rclone offers rich features such as encryption, compression, multi-threaded downloads, making it ideal for efficient cloud storage file management.\nIt supports the following features:\nOn-demand copying, only copying changed files each time Resume transfer after power outage Compressed transfer "},"title":"How to Efficiently Manage Cloud Storage Files with Rclone"},"/en/https-for-local-development/":{"data":{"":" Note: This article was translated from Chinese to English by Claude AI (Anthropic).\nI recently developed a webpage with QR code scanning functionality, but the scanning feature requires camera access, which browsers only allow in HTTPS environments for security reasons. Therefore, to debug these features locally, we need to configure HTTPS for the local development server. The core solution to this problem is generating local certificates and self-signing them. While there are many methods available online, I‚Äôll introduce two approaches here that you can follow along with - they should be sufficient for basic development needs.","built-in-options-for-vue--react#Built-in Options for Vue / React":"Both React and Vue come with built-in options for enabling HTTPS, making it even simpler to use HTTPS protocol locally.\nTaking vite as an example again, the official documentation mentions that if you need valid certificates, you can use their plugin @vitejs/plugin-basic-ssl, which automatically creates and caches a self-signed certificate.\n1. Install Plugin @vitejs/plugin-basic-ssl: pnpm add @vitejs/plugin-basic/ssl -D 2. Configure vite After configuring vite, you can run it directly. Note that browsers might show security warnings because our self-signed certificates aren‚Äôt issued by a trusted certificate authority, but this won‚Äôt affect development use - just don‚Äôt use it in production environments.\n// vite.config.js export default defineConfig({ // ... plugins: [ // ... basicSsl(), ], server: { // ... https: true, }, }) ","mkcert#mkcert":"mkcert is a simplified local CA tool for generating valid local HTTPS certificates. Here are the steps to use mkcert and configure certificates:\n1. Installation If you‚Äôre using macOS and have homebrew installed, you can install it this way:\nbrew instal mkcert brew install nss # This step is needed if you have Firefox installed, otherwise you'll get an error If you‚Äôre using Windows, you can click here to view installation steps.\n2. Install Local CA mkcert -install 3. Create Certificate for localhost mkcert localhost 127.0.0.1 ::1 After successful creation, the Terminal will display the certificate location and expiration date:\nThe certificate is at \"./localhost+2.pem\" and the key at \"./localhost+2-key.pem\" ‚úÖ It will expire on 25 March 2026 üóì 4. Store Certificates in Your Project Create a new folder in your project directory to manage certificates.\nFor example, I created a cert folder in my project directory and moved the generated localhost+2.pem and localhost+2-key.pem into it.\n5. Configure vite to Use HTTPS My project stack is vue3 + vite, so I‚Äôm configuring the vite.config.js file. If you‚Äôre using other build tools (like vue-cli + webpack), the configuration method is similar - just refer to the official documentation for appropriate adjustments. Note: Remember to restart the service after modifying the configuration.\n// vite.config.js import fs from 'fs'; import path from 'path'; export default defineConfig({ // ... server: { // ... https: { key: fs.readFileSync(path.resolve(__dirname, 'cert/localhost+2-key.pem')), cert: fs.readFileSync(path.resolve(__dirname, 'cert/localhost+2.pem')), }, }, }) "},"title":"Generating Local Certificates with mkcert/Vite"},"/en/module-management/":{"data":{"":"","commonjs#\u003ccode\u003eCommonJS\u003c/code\u003e":"","differences-between-esm-and-cjs#Differences Between \u003ccode\u003eESM\u003c/code\u003e and \u003ccode\u003eCJS\u003c/code\u003e":"","es-modules#\u003ccode\u003eES Modules\u003c/code\u003e":"","esm-backward-compatibility#\u003ccode\u003eESM\u003c/code\u003e Backward Compatibility":" Note: This article was translated from Chinese to English by Claude AI (Anthropic).\nModularization and Its Benefits The biggest difference between Node.js and browser JavaScript is that Node.js is modular.\nModularization Modularization is a programming paradigm that breaks down large, complex program systems into smaller, more manageable and maintainable parts. In modularization, each module performs a specific function while minimizing direct interaction with other modules. This approach has many advantages:\nEncapsulation. Each module encapsulates data and functionality internally and provides interfaces for external interaction. This helps hide internal implementation details and reduces interdependencies between modules. Reusability. Modularization allows developers to reuse code blocks across multiple parts of a project, or across multiple projects or applications, reducing duplicate code and improving overall code quality. Maintainability and Readability. Modular code is typically easier to understand and maintain, with each module responsible for clearly defined functionality, making the code more intuitive and easier to manage. Independence. Loose coupling between modules ensures that modifying one module will not or minimally affect other modules, facilitating the addition, updating, and fixing of functionality. Node.js‚Äôs Module Choices When Node.js was first created, JavaScript didn‚Äôt have a standard module mechanism, so Node.js initially adopted CommonJS (abbreviated as CJS below). Later, when JavaScript‚Äôs standard module mechanism ES Modules (abbreviated as ESM below) was born, browsers gradually began supporting ESM. Before Node.js supported ESM, compilation tools like Babel and bundling tools like Webpack were already compiling standard ESM module mechanisms into Node.js‚Äôs CJS module mechanism. Subsequently, Node.js v13.2.0 also introduced the standard ESM mechanism while maintaining compatibility with early CJS.\nSo now when writing Node.js modules, we have 3 approaches:\nDirectly use ESM, feasible in Node.js versions after v13.2.0. Use ESM but compile to CJS through Babel. Use CJS, as Node.js will continue to support both ESM and CJS for a long time to come. ES Modules export for exporting, import for importing\nExport Syntax exporting declaration\nexport let a, b export const a = 1, b = 2 export function functionName () {} export class ClassName {} export const { a, b } = obj export const [ a, b ] = arr For example:\n// hello.mjs export const name = 'River' // index.mjs import { name } from './hello.mjs' export list\nexport { name1, name2 } export { variable1 as name1, variable2 as name2 } export { variable1 as 'string name' } export { name1 as default } For example:\n// hello.mjs const name = 'River' const sayHello = (text) =\u003e `Hello ${text}!` export { name, sayHello as default } // index.mjs import { name } from './hello.mjs' import sayHello from './hello.mjs' console.log(sayHello(name)) // Hello River! default exports\nexport default expression export default function functionName() {} export default class ClassName {} Additionally, there‚Äôs the aggregating syntax export ... from ..., which won‚Äôt be detailed here. For more information, see MDN-JavaScript-export.\nImport Syntax Based on the above export methods, we can see that exported APIs are either default or non-default. To summarize, there are two different import methods for these two types of APIs (see examples above):\nimport { API } from module-path // non-default API import defaultAPI from module-path // default API Of course, like export, import can also use as to rename APIs.\nimport { variable1 as name1 } from module-path import * as foo from module-path The above import * as foo can generate an object foo from exported APIs, and the default API becomes foo.default.\nFile Extensions Note that in Node.js, .js files use the CommonJS specification by default for defining modules, while .mjs files use the ES Modules specification. For detailed rules about enabling these two, see the nodejs doc.\nTo use ESM to define modules in .js files, you can set type: module in the package.json configuration file.\nCommonJS module.exports for exporting, require for importing\nExport Syntax module.exports module.exports = { name1, name2 } module.exports = { name1: variable1, name2: variable2 } // Different from ES Module's as usage exports exports.a = 1 exports.b = 2 exports.functionName = () =\u003e a + b For example:\n// hello.js const name = 'River' const sayHello = (text) =\u003e `Hello ${text}!` module.exports = { name, sayHello } // index.js const { name, sayHello } = require('./hello.js') console.log(sayHello(name)) exports.propertyName is an early usage; now we should preferably use module.exports = { propertyName }. Note that these two syntaxes cannot be used simultaneously, as exports.propertyName will be overwritten by module.exports = { propertyName }.\nImport Syntax const { API } = require(module-path) Differences Between ESM and CJS The loading mechanism is key to understanding the core features of these two module systems and represents their fundamental difference.\nCJS Dynamic Loading Runtime Loading. Module dependencies are resolved during code execution. This means require() function calls are processed during code execution, allowing flexible use of template strings for dynamic path concatenation, for example: const libPath = ENV.supportES6 ? './es6/' : './' const myLib = require(`${libPath}lib.js`) You can also load modules based on program logic and conditions. For example, you can call require() within an if statement to load different modules based on different conditions. let api; if(condition) { api = require('./foo'); } else { api = require('./bar'); } Synchronous Loading. When network delay isn‚Äôt a concern, especially in server-side JavaScript (Node.js), modules are generally loaded from the local file system, making synchronous loading feasible. ESM Static Loading Compile-time Loading. Module dependencies are determined at compile time. import and export must be placed at the top level and cannot be included in functions or conditional statements. Asynchronous Loading. Asynchronous loading allows code to continue executing while modules are downloading and processing, solving blocking issues but making module management more complex. Dynamic Loading with ESM While ESM doesn‚Äôt allow import statements with dynamic paths or within statement blocks, it does allow dynamic loading through the import() function, which is asynchronous.\nDynamic import() returns a Promise that resolves to all exports of the imported module. You need to use .then(), async/await or similar methods to handle the imported module. For example:\n(async function() { const { functionName } = await import('./myModules.mjs) functionName() }()) Use cases:\nConditional Loading For example: if(someCondition) { import('./myModules.mjs') .then(module =\u003e { module.functionName() }) } Performance Optimization. For example, when handling large modules, using code splitting and lazy loading to reduce initial load time and improve performance. ESM Backward Compatibility In the Node.js environment, ES Modules is backward compatible with CommonJS. APIs exported by CJS can also be imported using import(), but only as a default import. For example:\n// foo.js const a = 1 const b = 2 const c = () =\u003e a + b module.exports = { a, b, c } // bar.mjs import abc from './foo.js' console.log(abc.a, abc.b, abc.c()) // 1, 2, 3 In other words, module.exports is equivalent to:\nconst abc = { a, b, c } export default abc ","modularization-and-its-benefits#Modularization and Its Benefits":""},"title":"Module Management"},"/en/mysql/":{"data":{"basic-usage#Basic Usage":"Connect to MySQL mysql -u root -p Enter password:****** Basic Commands Show Database List SHOW DATABASES; Create Database CREATE DATABASE testdb; Use Database USE testdb; Create Table CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(100), email VARCHAR(100) ); View Table Structure DESCRIBE users; Data Operations Insert Data INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com'); Query Data SELECT * FROM users; Update Data UPDATE users SET email = 'john.doe@example.com' WHERE name = 'John Doe'; Delete Data DELETE FROM users WHERE name = 'John Doe'; Common Features Conditional Queries SELECT * FROM users WHERE email LIKE '%@example.com'; Sorted Queries SELECT * FROM users ORDER BY name ASC; Aggregate Functions SELECT COUNT(*) FROM users; SELECT AVG(id) FROM users; Multi-table Operations Create Second Table CREATE TABLE orders ( order_id INT AUTO_INCREMENT PRIMARY KEY, user_id INT, product_name VARCHAR(100), FOREIGN KEY (user_id) REFERENCES users(id) ); Join Queries SELECT users.name, orders.product_name FROM users JOIN orders ON users.id = orders.user_id; The SELECT users.name, orders.product_name clause specifies the columns we want to extract from the database:\nThe name column from users table (users.name) The product_name column from orders table (orders.product.name) The FROM users clause specifies our first query table, the users table. The JOIN orders ON users.id = orders.user_id clause joins the two tables. It uses an inner join to associate the users table with the orders table. The join condition is users.id = orders.user_id. INNER JOIN returns all records from both tables that meet the condition. If a record has matching records in both users and orders tables, it will be included in the result set. In simple terms, this query returns all users who have orders and their order product names.\nFor example, given these two tables:\nusers table:\nid name 1 Alice 2 Bob 3 Charlie orders table:\norder_id user_id product_name 101 1 Laptop 102 1 SmartPhone 103 2 Tablet The query result will be:\nname product_name Alice Laptop Alice Smartphone Bob Tablet ","command-line-tools#Command Line Tools":"For all command line options, check the official documentation: mysql Client Commands\nHere are some common ones:\n\\g and \\G are both command terminators; alternatively, you can use ; to end commands.\n\\g # Send command to MySQL server \\G # Send command to MySQL server and format output \\c # Clear current input \\q # Exit MySQL ","common-issues#Common Issues":"","enter-mysql-cli#Enter MySQL CLI":" mysql -u root -p Enter the installation password to successfully enter MySQL CLI.","environment-variables#Environment Variables":"Check current shell\necho $SHELL If it shows /bin/bash, you‚Äôre using bash; if it shows /bin/zsh, you‚Äôre using zsh.\nFor bash:\n# 1. Edit vim ~/.bash_profile # 2. Add export PATH=${PATH}:/usr/local/mysql/bin # 3. Update source ~/.bash_profile For zsh:\n# 1. Edit vim ~/.zshrc # 2. Add export PATH=${PATH}:/usr/local/mysql/bin # 3. Update source ~/.zshrc ","error-1819-hy000-your-password-does-not-satisfy-the-current-policy-requirements#ERROR 1819 (HY000): Your Password Does Not Satisfy the Current Policy Requirements":"Running the following code will give an error:\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'admin' Error message: ERROR 1819 (HY000): Your password does not satisfy the current policy requirements. The password doesn‚Äôt meet security requirements. Change the password security requirements to fix this. Steps to resolve:\nLogin to MySQL\nmysql -u root -p Check current password policy\nSHOW VARIABLES LIKE 'validate_password%'; +-------------------------------------------------+--------+ | Variable_name | Value | +-------------------------------------------------+--------+ | validate_password.changed_characters_percentage | 0 | | validate_password.check_user_name | ON | | validate_password.dictionary_file | | | validate_password.length | 8 | | validate_password.mixed_case_count | 1 | | validate_password.number_count | 1 | | validate_password.policy | MEDIUM | | validate_password.special_char_count | 1 | +-------------------------------------------------+--------+ Modify current password policy\nSET GLOBAL validate_password.length=4; SET GLOBAL validate_password.policy=LOW; Now the password policy has been modified\n+-------------------------------------------------+-------+ | Variable_name | Value | +-------------------------------------------------+-------+ | validate_password.changed_characters_percentage | 0 | | validate_password.check_user_name | ON | | validate_password.dictionary_file | | | validate_password.length | 4 | | validate_password.mixed_case_count | 1 | | validate_password.number_count | 1 | | validate_password.policy | LOW | | validate_password.special_char_count | 1 | +-------------------------------------------------+-------+ Refresh privileges and try changing password again\nFLUSH PRIVILEGES ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'admin'; ","installation#Installation":"MySQL Community Server MySQL Community Server is the database server responsible for actually storing and managing data.\nDownload link: https://dev.mysql.com/downloads/mysql/\nSelect your version and operating system, then click the Download button. I‚Äôm using macOS 14 with an M1 chip, so I selected macOS 14 (ARM, 64-bit), DMG Archive for download.\nAfter installation, open System Settings, scroll to the bottom to find MySQL, and click the button to run the MySQL service.\nMySQL Workbench MySQL Workbench is a client application that you can use to connect to MySQL Community Server for database design, development, and management operations.\nMake sure to keep versions consistent. Download link: https://dev.mysql.com/downloads/workbench/\nAfter installation, open it, click on Connection or create a new one, enter the password and you‚Äôre good to go.","mysql-installation-and-usage#MySQL Installation and Usage":" Note: This article was translated from Chinese to English by Claude AI (Anthropic).\nMySQL Installation and Usage","no-apply-button-when-creating-table-in-mysql-workbench#No Apply Button When Creating Table in MySQL Workbench":"Version 8.0.36 has issues, replacing with 8.0.34 resolves this."},"title":"MySQL Installation and Basic Usage"},"/en/npm/":{"data":{"":" Note: This article was translated from Chinese to English by Claude AI (Anthropic).","npm#NPM":"NPM is the package manager that comes with Node.js.\nNode.js modules are broadly divided into internal modules and other modules. Internal modules are integrated within Node.js and don‚Äôt require referencing external JS files - they can be imported using require or import with the module name.\nFor example, the built-in fs module (for file operations) can be imported like this:\nconst fs = require('fs') Besides these built-in modules shown in the image, we often use many other modules in development. There are two ways to import them:\nImport using file paths\nFor example, in the project below, to import foo.js from directory a into bar.js in directory b:\n- a foo.js - b bar.js You can import it in bar.js like this:\nconst foo = require('../a/foo.js') Install modules into your project using NPM (by default in the node_modules directory) and reference them by package name in your code.\nnpm registry is NPM‚Äôs official repository where you can find needed packages and follow package documentation for installation and usage.\nFor example, the dayjs plugin can be installed using NPM:\nnpm install dayjs Usage:\nconst dayjs = require('dayjs') dayjs().format() When importing modules by package name, Node.js uses the resolve algorithm to first search the node_modules directory in the module‚Äôs location. If not found, it recursively searches node_modules in parent directories up to the root directory.\nThere‚Äôs a lot worth discussing about NPM - I‚Äôll create a separate topic for it in the future ‚úçÔ∏è."},"title":"NPM"},"/en/pre-knowledge-of-nodejs/":{"data":{"":" Note: This article was translated from Chinese to English by Claude AI (Anthropic).","basic-architecture#Basic Architecture":" Source: medium.com\nNode.js runs on top of the operating system, with its lower layer consisting of the Chrome V8 engine and some C/C++ libraries like libUv, c-ares, llhttp/http-parser, open-ssl, zlib, etc. LibUV handles event loops, while c-ares, llhttp/http-parser, open-ssl, zlib, and other libraries provide DNS resolution, HTTP protocol, HTTPS, and file compression capabilities.\nThe middle layer consists of Node.js Bindings, Node.js Standard Library, and C/C++ AddOns. The Node.js Bindings layer exposes the C/C++ library interfaces to the JS environment, while the Node.js Standard Library contains Node.js‚Äôs core modules. As for C/C++ AddOns, they allow users to bridge their own C/C++ modules to Node.js.\nAbove is Node.js‚Äôs API layer, which is what we primarily use when developing Node.js applications. Node.js applications ultimately run on top of the API layer.","nodejs-is-a-javascript-runtime-environment#Node.js is a JavaScript Runtime Environment":" Node.js¬Æ is an open-source, cross-platform JavaScript runtime environment.Source: Node.js\nNode.js is not a language but a platform, serving as a JavaScript runtime environment/host environment.\nAny discussion of Node.js inevitably involves the Chrome V8 engine. In 2009, Google began developing the Chrome browser, now the most widely used browser, and the Chrome V8 engine developed under Lars Bak‚Äôs leadership was born, launching a performance revolution for JavaScript. Node.js was built on the Chrome V8 engine. Later, Node.js creator Ryan Dahl also built Deno.\nToday, JavaScript‚Äôs architectural hierarchy has largely stabilized, as shown:\nSource: Juejin Books\nThe bottom layer is the scripting language specification (Spec), ECMAScript. Above that is language implementation, with JavaScript, JScript, ActionScript, etc., all implementing ECMAScript. At the engine level, besides Chrome V8 mentioned above, there are SpiderMonkey, QuickJS, JerryScript, and other common engines. The top layer consists of runtime environments, with Node.js, Chromium, Deno, and CloudFlare Workers based on Chrome V8, while Firefox is based on SpiderMonkey. ","use-cases#Use Cases":" Server-side\nNode.js provides event-driven and non-blocking interfaces for writing programs under high concurrency conditions. JavaScript‚Äôs anonymous functions, closures, callbacks, and other features were designed for event-driven programming.\nSome of Node.js‚Äôs built-in modules like http, net, fs were designed for server-side use. Whether it‚Äôs HTTP, TCP, UDP, or RPC services, Node.js can handle them all.\nDesktop Applications\nElectron.js, an open-source framework developed and maintained by the OpenJS Foundation, aims to create desktop applications using web technologies with the Chromium browser engine and Node.js runtime environment.\nSoftware like Visual Studio Code, 1Password, DingTalk are all developed using Electron.\nPC Games\nBesides writing browser-based games using WebGL or packaging games through Electron, JavaScript can also create genuine desktop games through Node.js bindings to use OpenGL or even DirectX.\nMachine Learning\npipcook\nWhile Node.js was originally conceived as a technology for building server-side applications, as a JavaScript runtime environment operating within the operating system, it has evolved into a platform spanning front-end and back-end development, traditional services and Serverless, tools, business applications, games, and more."},"title":"Node.js Prerequisites"},"/en/vue-reactivity-source-code-review/":{"data":{"":"","vue-2-reactivity-principles#Vue 2 Reactivity Principles":"","vue2-reactivity-system-limitations#Vue2 Reactivity System Limitations":"","vue3s-improvements-to-reactivity#Vue3\u0026rsquo;s Improvements to Reactivity":" Note: This article was translated from Chinese to English by Claude AI (Anthropic).\nVue 2 Reactivity Principles In Vue 2, when a JavaScript object is passed into a Vue instance as a data option, Vue will traverse all properties of this object and use Object.defineProperty() to convert these properties into getters/setters. Dependencies are collected in the getter and updates are triggered in the setter: each component instance corresponds to a watcher instance, which records data properties accessed during component rendering as dependencies. When a dependency‚Äôs setter is triggered, it notifies the watcher, causing its associated component to re-render. This is the approach behind Vue 2‚Äôs reactivity implementation. As for how it is specifically implemented, we‚Äôll analyze this in detail below.\nObject.defineProperty() Object.defineProperty() is the foundation of Vue‚Äôs reactivity implementation. It allows precise addition or modification of properties on an object. The syntax is as follows:\nObject.defineProperty(obj, prop, descriptor) Parameters: obj: The object on which to define the property prop: The name of the property to be defined or modified descriptor: The descriptor for the property being defined or modified\nCommon properties of descriptor:\nenumerable: Whether the property is enumerable, defaults to false configurable: Whether the property can be modified or deleted, defaults to false get: Method for getting the property set: Method for setting the property Reference: MDN-Object.defineProperty()\nLet me continue with the implementation part.\nImplementing Reactivity In Vue‚Äôs source code, the defineReactive function wraps Object.defineProperty to implement reactivity. get triggers reactiveGetter to collect dependencies, while set triggers reactiveSetter to notify dependencies to update. Below is a simplified version of this function‚Äôs source code, just focus on the non-commented parts:\nParameters:\nobj (object to bind) key (object property name) val (specific value) function defineReactive(obj, key, val) { // Create dependency collector // const dep = new Dep() Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter() { // Collect dependencies // if (Dep.target) { // dep.depend() // } return val }, set: function reactiveSetter(newVal) { if (newVal === val) return val = newVal // Notify all dependencies // dep.notify() } }) } As mentioned at the beginning of this article, Vue traverses all properties of an object, so we need to wrap another layer called Observer to traverse the object and convert all properties of a regular JavaScript object into reactive ones. Here‚Äôs a simplified version:\nclass Observer { constructor(value) { // Add __ob__ property to the observed object, pointing to this Observer instance def(value, '__ob__', this) if(Array.isArray(value)) { // Intercept array methods // ... // Process array this.observeArray() } else { // Process object const keys = Object.keys(value) for (let i = 0; i \u003c keys.length; i++) { const key = keys[i] defineReactive(value, key, NO_INITIAL_VALUE, undefined, shallow, mock) } } } observeArray(value) { for (let i = 0, l = value.length; i \u003c l; i++) { observe(value[i], false, this.mock) } } } Here, def() is a utility function used to add properties to an object:\nexport function def(obj, key, val) { Object.defineProperty(obj, key, { value: val, }) } observe() is the entry function that returns an Observer instance:\nfunction observe(value) { if (typeof value !== 'object') return let ob if (hasOwn(value, '__ob__') \u0026\u0026 value.__ob__ instanceof Observer) { ob = value.__ob__ } else { ob = new Observer(value) } return ob } Dependency Collection The previously commented out lines in defineReactive, highlighted below, are for dependency collection in get and notification of all dependencies in set - this is another important part of implementing the reactivity system - dependency collection.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function defineReactive(obj, key, val) { // Create dependency collector const dep = new Dep() Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter() { // Collect dependencies if (Dep.target) { dep.depend() } return val }, set: function reactiveSetter(newVal) { if (newVal === val) return val = newVal // Notify all dependencies dep.notify() } }) } Why Dependency Collection is Needed Let‚Äôs look at an example. Here‚Äôs a Vue object:\nnew Vue({ template:` \u003cdiv\u003e \u003cspan\u003e{{ text1 }}\u003c/span\u003e \u003cspan\u003e{{ text2 }}\u003c/span\u003e \u003c/div\u003e `, data: { text1: 'text1', text2: 'text2', text3: 'text3', } }) If we modify text3:\ndata.text3 = 'text3 modify' Although we modified the value of text3 in data, since text3 isn‚Äôt used in the template rendering, it won‚Äôt trigger dep.notify() to notify dependencies and update the view.\nHere‚Äôs another example. Suppose we have a global object that we use in two Vue objects.\nlet globalObj = { text1: 'text1' } let o1 = new Vue({ template:` \u003cdiv\u003e\u003cspan\u003e{{ globalObj.text1 }}\u003c/span\u003e\u003c/div\u003e `, data: { globalObj } }) let o2 = new Vue({ template:` \u003cdiv\u003e\u003cspan\u003e{{ globalObj.text1 }}\u003c/span\u003e\u003c/div\u003e `, data: { globalObj } }) When we modify the value of globalObj.text1:\nglobalObj.text1 = 'text1 modify' In the reactivity system, when globalObj.text1 changes, it should notify both o1 and o2 vm instances to update their views. Dependency collection implements this: it lets this data (globalObj.text1) know that two places (o1 and o2) depend on it, so when this data (globalObj.text1) changes, it will notify the o1 and o2 that depend on it.\nCore of Dependency Collection - Dep and Watcher Let‚Äôs return to the code to see how dependency collection is implemented.\nFirst, we need a Dep. Each Dep instance has an array to store watchers, which will notify watchers to update when data changes. Similarly, each Watcher instance also has an array to store its dependent deps. In other words, dependency collection is bidirectional - Dep records Watcher, and Watcher also records Dep, this is very important.\nMany-to-many relationship, reactive Object contains Dep, Dep contains multiple Watchers, Watcher is responsible for notifying dependencies to update.\nLet‚Äôs look at Dep first:\nclass Dep { static target // Static property, globally unique currently executing Watcher id // Instance property, unique identifier for each dep subs // Instance property, stores all subscribers constructor { this.id = uid++ this.subs = [] } // Add subscriber addSub(sub) { this.subs.push(sub) } // Remove subscriber removeSub(sub) { remove(this.subs, sub) } // Establish dependency relationship depend() { if(Dep.target) { // If there is a currently executing Watcher, use it as dependency Dep.target.addDep(this) } } // Notify all subscribers notify() { for(let i = 0, l = this.subs.length; i \u003c l; i++) { this.subs[i].update() } } } Dep.target = null; As mentioned above, class Dep‚Äôs target is a static property used to record the currently unique executing Watcher, id is used to give Dep instances unique identifiers, and subs is used to store all subscribers. addSub() and removeSub() are used to add and remove subscribers, depend() is used to establish dependency relationships, and notify() is used to notify all subscribers.\nWatcher is a bit more complex, let‚Äôs take a look:\nclass Watcher { constructor (vm, expOrFn, cb, options={}) { if(options) { this.lazy = !!this.lazy this.sync = !!this.sync } this.vm = vm // Vue instance this.cb = cb // Callback function this.deps = [] // Store all deps this watcher depends on this.newDeps = [] // New deps collected in this round this.depIds = new Set() // Set of dependency IDs for deduplication this.newDepIds = new Set() // Set of new dependency IDs this.expression = expOrFn.toString() // For debugging this.dirty = this.lazy this.id = ++uid // Unique identifier // Define getter here if(typeof expOrFn === 'function') { this.getter = expOrFn // If expOrFn is a function, use it directly as getter } else { this.getter = parsePath(expOrFn) // If it's a string, convert to function that gets object property } // Execute getter immediately once for initialization and dependency collection this.value = this.lazy ? undefined : this.get() } get() { pushTarget(this) // Set current watcher as globally active watcher let value try { // Execute getter, triggering observed object's getter, thus collecting dependencies value = this.getter.call(this.vm, this.vm) } catch (e) { throw e } finally { popTarget() // Restore previous active watcher this.cleanupDeps() // Clean up dependencies } return value } addDep(dep) { const id = dep.id // Check if already in new dependency collection if(!this.newDepIds.has(id)) { // Add to new dependency ID set this.newDepIds.add(id) // Add to new dependency array this.newDeps.push(dep) // Check if in old dependencies if(!this.depIds.has(id)) { // If not in old dependencies, let dep collect current watcher dep.addSub(this) } } } // Clean up dependencies cleanupDeps() { let i = this.deps.length // Traverse old dependency array while (i--) { const dep = this.deps[i] // If new dependency array doesn't include this old dependency if (!this.newDepIds.has(dep.id)) { // Remove this watcher from dep dep.removeSub(this) } } // Update depIds, clear newDepIds let tmp: any = this.depIds this.depIds = this.newDepIds this.newDepIds = tmp this.newDepIds.clear() // Update deps, clear newDeps tmp = this.deps this.deps = this.newDeps this.newDeps = tmp this.newDeps.length = 0 } update() { // Lazy mode, lazy computation, won't recompute immediately, just mark dirty as true if (this.lazy) { this.dirty = true } else if (this.sync) { // Sync mode, synchronous update mode, update immediately this.run() } else { // Default async update mode, put watcher into update queue queueWatcher(this) } } run() { const value = this.get() // Get new value if(value !== this.value || isObject(value) || this.deep) { // If new value != old value | new value is object | deep watching const oldValue = this.value // Save old value this.value = value // Set new value this.cb.call(this.vm, value, oldValue) // Execute callback function, passing new and old values } } } In Watcher‚Äôs constructor, it first processes the passed expOrFn. When it‚Äôs a function, it‚Äôs directly assigned to getter. If it‚Äôs a string, it needs parsePath to convert it to an access function. For example, parsePath('user.name') would return a function: (obj) =\u003e obj['user']['name']. Note that obj here is the vm called in getter.call, which is the current Vue instance. Additionally, it will immediately execute getter() once for initialization and dependency collection.\nLooking at the code below, to handle nested Watcher scenarios, at the start of getter(), the current Watcher (target) is pushed onto the targetStack stack, and Dep.target is pointed to the current Watcher. When getter() finishes, this Watcher is popped from the stack, and Dep.target‚Äôs pointer is modified to the previous Watcher.\nconst targetStack = [] export function pushTarget(target) { targetStack.push(target) Dep.target = target } export function popTarget() { targetStack.pop() Dep.target = targetStack[targetStack.length - 1] } The addDep method of Watcher and the addSub method in Dep call each other for bidirectional dependency collection. Don‚Äôt worry about infinite loops, as Watcher also has a cleanupDeps to clean up dependencies in a timely manner.\nupdate() and run() are responsible for update handling when data changes. Let‚Äôs first look at update(), which has three ways of handling when data changes:\nlazy mode\nif(this.lazy) { this.dirty = true } Searching for dirty in the source code, we can find the evaluate() method:\n/** * Evaluate the value of the watcher. * This only gets called for lazy watchers. */ evaluate() { this.value = this.get() this.dirty = false } When evaluate() is called, it calls the get() method and sets dirty to false. So where is evaluate() used? After a global search, we can see it being called in the state.ts file:\nfunction createComputedGetter(key) { return function computedGetter() { const watcher = this._computedWatchers \u0026\u0026 this._computedWatchers[key] if (watcher) { if (watcher.dirty) { watcher.evaluate() } if (Dep.target) { // ... watcher.depend() } return watcher.value } } } In other words, when the computed property‚Äôs getter() is called, if this watcher is dirty data (dirty is true), then evaluate() will be executed. Using lazy mode won‚Äôt immediately recalculate values, it just marks dirty as true, waiting until the next access to this property to actually calculate. The computed property uses this mode.\nsync mode\nelse if(this.sync) { this.run() } If in sync mode, it will call run():\nrun() { const value = this.get() // Get new value if(value !== this.value || isObject(value) || this.deep) { // If new value != old value | new value is object | deep watching const oldValue = this.value // Save old value this.value = value // Set new value this.cb.call(this.vm, value, oldValue) // Execute callback function, passing new and old values } } We can see that the run method immediately executes get(), and when the new and old values are not equal or the new value is an object or deep watching is enabled, it executes the callback function, passing both new and old values. So sync mode is mainly used for scenarios that need immediate response to data changes, but sync is false by default, and most cases use async asynchronous updates.\nqueue asynchronous updates\nelse { queueWatcher(this) } Let‚Äôs see what queueWatcher() does:\nlet has = {} /** * Push a watcher into the watcher queue. * Jobs with duplicate IDs will be skipped unless it's * pushed when the queue is being flushed. */ export function queueWatcher(watcher: Watcher) { // Duplicate check to prevent the same watcher from being added to the queue multiple times const id = watcher.id if (has[id] != null) { return } // Prevent watcher from triggering recursive updates during its own update process if (watcher === Dep.target \u0026\u0026 watcher.noRecurse) { return } has[id] = true if (!flushing) { // If queue hasn't started flushing, push into queue queue.push(watcher) } else { // If queue is flushing, need to insert according to id order // Ensure watchers execute in order of creation (id size) because: 1.parent component watchers need to update before child components 2.computed needs to update before regular watchers let i = queue.length - 1 while (i \u003e index \u0026\u0026 queue[i].id \u003e watcher.id) { i-- } queue.splice(i + 1, 0, watcher) } // queue the flush if (!waiting) { waiting = true // Ensure queue will be flushed in next tick nextTick(flushSchedulerQueue) } } When flushSchedulerQueue is executed, flushing will be set to true By calling flushSchedulerQueue() through nextTick(), it executes flushSchedulerQueue() in the next microtask, so multiple data modifications will only trigger one update. Vue Reactivity System Through the above sections, we know that Vue‚Äôs reactivity system implementation relies on data reactivity and dependency collection. The core/principle of data reactivity is Object.defineProperty, which registers get and set for dependency collection. Specifically, it creates a new Dep instance in the reactive object to handle dependency collection, adding the current Watcher to the Dep instance‚Äôs subscriber list (subs). At this point, the process of building the entire reactivity system is still somewhat unclear, especially when new Watcher() happens, so when we create a new Vue instance, when are all these processes performed?\nFirst, we need to know what Watchers exist in a Vue instance. As Vue users, we commonly encounter three types: Render Watcher, Computed Watcher, and User Watcher:\n// Template rendering - Render Watcher \u003cdiv\u003e{{ message }}\u003c/div\u003e // computed option - Computed Watcher computed: { total() { return this.price * this.quantity } } // watch option - User Watcher watch: { price(newVal, oldVal) { console.log('price change:', newVal) } } Now, let‚Äôs not rush to focus on when new Watcher happens, let‚Äôs first understand the overall flow of new Vue():\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 function initMixin(Vue) { Vue.prototype._init = function () { const vm = this // Initialize lifecycle initLifeCycle(vm) // Initialize events initEvent(vm) // Initialize render initRender(vm) // Call beforeCreate Hook callHook(vm, 'beforeCreate') // Initialize inject initInject(vm) // Initialize state initState(vm) // Initialize provide initProvide(vm) // Call created Hook callHook(vm, 'created') // If there's an el option, mount automatically if(vm.$options.el) { vm.$mount(vm.$options.el) // Create Render Watcher } } } We mainly focus on initState and $mount.\ninitState initState initializes props -\u003e methods -\u003e data -\u003e computed -\u003e watch in sequence:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function initState(vm) { const opts = vm.$options // 1. Initialize props if (opts.props) initProps(vm, opts.props) // 2. Initialize methods if (opts.methods) initMethods(vm, opts.methods) // 3. Initialize data if (opts.data) { initData(vm) // Generate reactive object } // 4. Initialize computed if (opts.computed) initComputed(vm, opts.computed) // 5. Initialize watch if (opts.watch \u0026\u0026 opts.watch !== nativeWatch) { initWatch(vm, opts.watch) } } The process of generating reactive objects, which we mentioned earlier using Object.defineProperty, is implemented in initData:\nfunction initData() { observe(data) // Entry function for generating reactive objects mentioned earlier } initComputed and initWatch create Computed Watcher and User Watcher respectively:\nfunction initComputed() { // Create computed watcher for each computed property new Watcher(vm, getter, null, options) } function initWatch() { // Create user watcher for each watch new Watcher(vm, key, cb, options) } $mount Render Watcher is created during component mounting ($mount).\n// Create render watcher (during mount phase) Vue.prototype.$mount = new Watcher(vm, updateComponent, null, options) Vue2 Reactivity System Limitations Vue2‚Äôs reactivity isn‚Äôt perfect. The implementation using Object.defineProperty comes with inherent limitations, so when using Vue2, we need to be aware of these issues.\nObjects Vue2 cannot detect object property additions and deletions.\nFor example:\nvar vm = new Vue({ data: { a: 1 } }) // vm.a is reactive vm.b = 2 // vm.b is non-reactive This is because Vue converts properties to reactive ones during instance initialization, so properties must exist on the data object for Vue to make them reactive.\nfunction initData(vm) { let data = vm.$options.data observe(data) // Call observe here to make object reactive } Solution 1: Vue.set For already created instances, while Vue doesn‚Äôt allow adding reactive properties at the root level, you can use Vue.set(object, propertyName, value) to add reactive properties to nested objects.\nFor example, if you have an object in data:\nvar vm = new Vue({ data: { someObject: { a: 1, } } }) Use Vue.set to add a new reactive property b to someObject:\nVue.set(vm.someObject, 'b', 2) or\nthis.$set(this.someObject, 'b', 2) Solution 2: Object.assign When you need to assign multiple new properties to an existing object, you can use Object.assign.\nthis.someObject = Object.assign({}, this.someObject, {a: 1, b: 2}) However, note that new properties added like this aren‚Äôt reactive:\nObject.assign(this.someObject, {a: 1, b: 2}) The reason is simple - Object.assign(this.someObject,{a:1,b:2}) is equivalent to directly modifying/adding properties:\n// Equivalent to this.someObject.a = 1 // Triggers a's setter this.someObject.b = 2 // b remains non-reactive While Object.assign({},this.someObject,{a:1,b:2}) triggers someObject‚Äôs setter, recursively traversing all properties on someObject for reactive conversion.\nArrays Vue2 cannot detect changes to array indices and length.\nArray indices: vm.items[indexOfItem] = newValue Array length: vm.items.length = newLength These two types of changes won‚Äôt trigger reactive updates because array indices are essentially object properties. While theoretically Vue could handle array indices like object properties, for arrays with large lengths, like an array of 10000 elements, setting getter/setter for each index would cause serious performance issues. Similarly, the length property of arrays isn‚Äôt made reactive because it could trigger chain reactions (modifying length could affect many elements).\nTo solve this problem, Vue2 rewrote seven array methods that can trigger reactive updates:\npush() pop() shift() unshift() splice() sort() reverse() So to trigger array reactivity, you should do this:\n// Modify array index vm.items.splice(indexOfItem, 1, newValue) // Modify array length vm.items.splice(2) Performance Vue2‚Äôs reactive implementation requires recursive traversal of all object properties, which itself has significant performance overhead. This is also why Vue3 switched to using proxy to implement reactivity.\nVue3‚Äôs Improvements to Reactivity Implementing Reactivity with Proxy Vue3‚Äôs reactivity system is based on ES6‚Äôs proxy, which is a major upgrade from Vue2‚Äôs Object.defineProperty. The advantages include:\nCan detect object property additions and deletions Can monitor array changes without additional handling No need for deep recursive traversal, better performance Supports data structures like Map, Set function reactive(target) { return new Proxy(target, { get(target, key, receiver) { const res = Reflect.get(target, key, receiver) track(target, key) // Dependency collection return res }, set(target, key, value, receiver) { const res = Reflect.set(target, key, value, receiver) trigger(target, key) // Trigger updates return res } }) } Here Reflect is a built-in object that provides methods for intercepting JavaScript operations.\nReflect.get(target, key) // Get property Reflect.set(target, key, value) // Set property Reflect.has(target, key) // Check property Reflect.deleteProperty(target, key) // Delete property Reflect provides unified APIs for object operations, making it convenient for proxy:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function reactive(target) { return new Proxy(target, { get(target, key, receiver) { // Using Reflect ensures correct this binding const res = Reflect.get(target, key, receiver) track(target, key) return res }, set(target, key, value, receiver) { // Returns boolean indicating if operation succeeded const res = Reflect.set(target, key, value, receiver) trigger(target, key) return res } }) } New Reactive APIs ref and reactive ref and reactive are both new reactive APIs in Vue3 for handling reactive data, with some differences in usage:\nFeature ref reactive Access method Access via .value Direct access Auto-unwrapping Auto-unwraps in \u003ctemplate\u003e and reactive No unwrapping needed Data type support Supports all data types Only supports object types Destructuring behavior Loses reactivity after destructuring, need toRef/toRefs Loses reactivity after destructuring, need toRef/toRefs Assignment characteristic Can directly replace entire value ref.value = newValue Can‚Äôt directly replace entire object, can only modify properties Nested data Internally uses reactive to handle objects Deep reactive conversion Use cases Basic data types / Single data source / Composition function return values / Data needing reassignment Related data collections / Reference data types / Data not needing reassignment Access Method ref objects are accessed via .value, reactive accessed directly.\nconst count = ref(0) console.log(count.value) // needs .value to access const obj = reactive({ count: 0 }) console.log(obj.count) // direct access, no .value needed Auto-unwrapping ref objects auto-unwrap in template, reactive\n\u003ctemplate\u003e \u003cdiv\u003e \u003c!-- Already auto-unwrapped, direct access, no .value needed ---\u003e {{ count }} \u003c/div\u003e \u003c/template\u003e \u003cscript setup\u003e const count = ref(0) // ref auto-unwraps in reactive objects const state = reactive({ count, // auto-unwrapped double: computed(() =\u003e state.count*2), }) \u003c/script\u003e Data Type Support // ref supports all data types const num = ref(0) const str = ref('XD') const boo = ref(true) const obj = ref({a:1, b:2}) const arr = ref([1,2]) // reactive only supports reference data types (objects/arrays) const obj2 = reactive({a:1, b:2}) const arr2 = reactive([1,2]) Using toRef / toRefs for Destructuring const obj = reactive({name: 'River', age: 18}) const { age } = obj // Direct destructuring will lose reactivity // Using toRef const age = toRef(obj, 'age') // Or toRefs const { name, age } = toRefs(obj) // The benefit is maintaining object reactivity // Modifying ref will update source object age.value++ console.log(obj.age) // 19 // Modifying source object will update ref obj.age++ console.log(age.value) // 20 Assignment Characteristics ref objects can be directly replaced, reactive cannot be directly replaced, only properties can be modified\nconst foo = ref([1,2]) foo.value = [3,4] // allowed const foo = reactive([1,2]) foo = [3,4] // not allowed Nested Data ref handling nested data\nconst user = ref({ name: 'Zhang', profile: { age: 25, address: { city: 'Beijing' } } }) // ref internally uses reactive for deep object conversion user.value.profile.age = 26 // triggers reactive update user.value.profile.address.city = 'Shanghai' // triggers reactive update reactive handling nested data\nconst user = reactive({ name: 'Zhang', profile: { age: 25, address: { city: 'Beijing' } } }) // reactive deeply converts all nested objects user.profile.age = 26 // triggers reactive update user.profile.address.city = 'Shanghai' // triggers reactive update Use Cases For composition function return values, using ref is better. If reactive is needed, maintain data reactivity through toRefs\nfunction useCount() { const count = ref(0) return count } function useUser() { const state = reactive({name: 'River', age: 18}) return toRefs(state) } watchEffect watchEffect automatically tracks reactive dependencies and reruns the effect function when reactive dependencies update. Simply put, it does these things:\nImmediately executes the callback function once Automatically tracks reactive dependencies used in the callback function Reruns the callback function when dependencies change Basic Usage import { ref, watchEffect } from 'vue' const count = ref(0) const message = ref('Hello') watchEffect(() =\u003e { console.log(`Count: ${count.value}, Message: ${message.value}`) }) // Modifying any dependency will trigger callback count.value++ // Output: Count: 1, Message: Hello message.value = 'Hi' // Output: Count: 1, Message: Hi Pause/Resume/Stop Watching watchEffect also returns a stop function, executing it will stop watching\nconst stop = watchEffect(() =\u003e {}) // When watching is no longer needed stop() When pausing/resuming is needed\nconst { stop, pause, resume } = watchEffect(() =\u003e {}) // Pause pause() // Resume resume() // Stop stop() Cleanup Effects Why cleanup effects are needed:\nPrevent memory leaks (like timers) Avoid duplicate event listeners Cancel unnecessary network requests Clean up potentially conflicting old states The onCleanup parameter in watchEffect‚Äôs callback function is used to clean up side effects. It executes at these times:\nJust before watchEffect is about to re-execute When watchEffect is stopped Let‚Äôs take a network request as an example, creating a network request controller controller and calling the cancel network request method in the onCleanup function.\nconst userId = ref('1') const userData = ref(null) watchEffect((onCleanup) =\u003e { // Create a cancel controller const controller = new AbortController() // Network request fetch(`/api/user/${userId.value}`, { signal: controller.signal, }).then(data =\u003e userData.value = JSON.parse(data)) // Cleanup function: cancel previous request if userId changes onCleanup(() =\u003e { controller.abort() }) }) setTimeout(() =\u003e { userId.value = '2' }, 100) The execution sequence is like this:\nMarkdownInitial execution: 1. Start request, userId: 1 100 ms later when userId changes: 2. Execute cleanup, cancel previous network request (cleanup previous side effect `onCleanup`) 3. Request canceled (previous request `abort`) 4. Start request, userId: 2 (re-execute `watchEffect`) Cleanup after 3.5+\nimport { onWatcherCleanup } from 'vue' // ... watchEffect(() =\u003e { // ... onWatcherCleanup(() =\u003e { controller.abort() }) // ... }) // ... Execution Timing watchEffect also provides a second parameter that can control when the effect function executes.\n1 2 3 4 5 6 7 8 9 10 11 12 // Default: execute before component updates, flush: 'pre' watchEffect(() =\u003e {}) // Execute after component updates watchEffect(() =\u003e { // ... }, { flush: 'post' }) // Synchronous execution watchEffect(() =\u003e { // ... }, { flush: 'sync' }) watchEffect vs watch watchEffect automatically tracks dependencies, watch needs explicitly specified source to monitor watchEffect(() =\u003e console.log(count.value)) // automatically tracks dependencies watch(count, newVal =\u003e console.log(count.value)) // explicitly specifies dependency watchEffect executes immediately by default, watch needs immediate: true setting watchEffect(() =\u003e {}) // executes immediately by default watch(source, () =\u003e {}, { immediate: true }) // won't execute immediately by default, needs immediate set to true "},"title":"Vue Reactivity Source Code Review"}}